<!DOCTYPE html>
<html lang='ru'>
  <head>
    <meta charset='utf-8'>
    <link href='/summaries/stylesheet.css' rel='stylesheet'>
    <title>Git</title>
  </head>
  <body>
    <header>
      <h1>Git</h1>
    </header>
    <main>
      <h1 id="Содержание">Содержание</h1>
      
      <p><a href="#Глоссарий">Глоссарий</a></p>
      
      <p><a href="#Элементы">Элементы</a></p>
      
      <p><a href="#Конфигурация">Конфигурация</a></p>
      
      <p><a href="#Создание_нового_репозитория">Создание нового репозитория</a></p>
      
      <p><a href="#Атрибуты">Атрибуты</a></p>
      
      <p><a href="#Закрепленные_сценарии">Закрепленные сценарии</a></p>
      
      <p><a href="#Выставление">Выставление</a></p>
      
      <p><a href="#Откладывание_правок">Откладывание правок</a></p>
      
      <p><a href="#Фиксация_правок">Фиксация правок</a></p>
      
      <p><a href="#Исправление_и_откат_сделанных_передач">Исправление и откат сделанных передач</a></p>
      
      <p><a href="#Журналирование">Журналирование</a></p>
      
      <p><a href="#Просмотр_изменений">Просмотр изменений</a></p>
      
      <p><a href="#Ветвление">Ветвление</a></p>
      
      <p><a href="#Слияние">Слияние</a></p>
      
      <p><a href="#Перебазирование">Перебазирование</a></p>
      
      <p><a href="#Метки">Метки</a></p>
      
      <p><a href="#Работа_с_удаленными_репозиториями">Работа с удаленными репозиториями</a></p>
      
      <p><a href="#Субмодули">Субмодули</a></p>
      
      <p><a href="#Архивирование">Архивирование</a></p>
      
      <p><a href="#Патчи">Патчи</a></p>
      
      <p><a href="#Отправка_патчей_по_электронной_почте">Отправка патчей по электронной почте</a></p>
      
      <p><a href="#Восстановление_и_очистка">Восстановление и очистка</a></p>
      
      <p><a href="#Пошаговый_поиск_проблемных_передач">Пошаговый поиск проблемных передач</a></p>
      
      <p><a href="#Gitosis">Gitosis</a></p>
      
      <p><a href="#Примеры">Примеры</a></p>
      
      <h1 id="Глоссарий">Глоссарий</h1>
      
      <p><strong>commit</strong></p>
      
      <p><em>фиксация правок в файле</em></p>
      
      <p><strong>to commit</strong></p>
      
      <p><em>зафиксировать правки в файле</em></p>
      
      <p id="staged_area"><strong>staged area</strong></p>
      
      <p><em>область выставления</em>, тж. <em>индекс</em></p>
      
      <p id="unstaged_area"><strong>unstaged area</strong></p>
      
      <p><em>невыставленная область</em>; <em>рабочая область</em></p>
      
      <p><strong>to stage</strong></p>
      
      <p><em>выставить файл</em>; <em>переместить файл в индекс</em></p>
      
      <p><strong>to unstage</strong></p>
      
      <p><em>отменить выставление</em>; <em>вернуть файл в рабочую область</em>; <em>удалить файл из
      индекса</em></p>
      
      <p id="tracked_file"><strong>tracked file</strong></p>
      
      <p><em>отслеживаемый файл</em>; <em>включенный файл</em> (в репозиторий)</p>
      
      <p id="untracked_file"><strong>untracked file</strong></p>
      
      <p><em>неотслеживаемый файл</em>; <em>невключенный файл</em></p>
      
      <p><strong>to track</strong></p>
      
      <p><em>включить файл</em> (в репозиторий) для отслеживания изменений в нём</p>
      
      <h1 id="Элементы">Элементы</h1>
      
      <p id="ссылка"><strong>ссылка</strong> (<em>reference</em>, <em>ref</em>)</p>
      
      <p>указатель на последнюю версию цепочки правок</p>
      
      <h1 id="Конфигурация">Конфигурация</h1>
      
      <p><a href="#Команды_конфигурации">Команды конфигурации</a></p>
      
      <p><a href="#Опции">Опции</a></p>
      
      <h2 id="Команды_конфигурации">Команды конфигурации</h2>
      
      <p><strong><code>git config --system</code></strong> <em><code>option</code></em> <em><code>value</code></em></p>
      
      <p><em>системная (/etc/gitconfig)</em></p>
      
      <p><strong><code>git config --global</code></strong> <em><code>option</code></em> <em><code>value</code></em></p>
      
      <p><em>глобальная (~/.gitconfig)</em></p>
      
      <p><strong><code>git config</code></strong> <em><code>option</code></em> <em><code>value</code></em></p>
      
      <p><em>локальная (.git/config)</em></p>
      
      <h2 id="Опции">Опции</h2>
      
      <p><strong><code>alias.</code></strong><em><code>old_command</code></em> <em><code>new_command</code></em></p>
      
      <p><em>добавить замену для стандартной команды</em></p>
      
      <p><em>При замене глобальной команды следует поставить „!“ перед заменяемой командой:</em></p>
      
      <p><em><code>git config --global alias.visual'!gitk'</code></em></p>
      
      <p><strong><code>core.editor</code></strong> <em><code>editor</code></em></p>
      
      <p><em>добавить текстовый редактор</em></p>
      
      <p><strong><code>core.pager</code></strong> <em><code>pager</code></em></p>
      
      <p><em>установить пэйджер. Можно отключить использование пэйджера, передав пустую строку (<code>''</code>) в качестве значения</em></p>
      
      <p><strong><code>core.quotepath false</code></strong></p>
      
      <p><em>запретить вывод имен файлов в формате Unicode в виде числовых кодов при выполнении <code>git status</code></em></p>
      
      <p><strong><code>merge.tool</code></strong> <em><code>merge_tool</code></em></p>
      
      <p><em>добавить инструмент сравнения файлов</em></p>
      
      <p><strong><code>commit.template</code></strong> <em><code>template</code></em></p>
      
      <p><em>установить шаблон для записи передачи</em></p>
      
      <p><strong><code>core.excludesfile</code></strong> <em><code>path</code></em></p>
      
      <p><em>установить внешний файл с исключениями</em></p>
      
      <p><strong><code>help.autocorrect 1</code></strong></p>
      
      <p><em>установить автоматическое исправление опечаток</em></p>
      
      <p><strong><code>color.ui</code></strong> <em><code>{true | false | always}</code></em></p>
      
      <p><em>настроить цветной вывод. При установке опции always, цветной вывод будет присутствовать даже при перенаправлении данных в файл или другой команде</em></p>
      
      <h1 id="Создание_нового_репозитория">Создание нового репозитория</h1>
      
      <p><strong><code>git init</code></strong></p>
      
      <p><em>ининциализировать репозиторий</em></p>
      
      <p><strong><code>git status</code></strong></p>
      
      <p><em>вывести текущий статус</em></p>
      
      <p><strong><code>git checkout --</code></strong> <em><code>filename</code></em></p>
      
      <p><em>откатить сделанные в файле правки</em></p>
      
      <h1 id="Атрибуты">Атрибуты</h1>
      
      <p>Атрибуты задаются в файлах <em><code>./.gitattributes</code></em> или <em><code>./.git/info/attributes</code></em>.</p>
      
      <p>Формат задания атрибутов в указанных выше файлах следующий: <em><code>path attribute</code></em>.</p>
      
      <p><em><code>path</code></em> <strong><code>export-ignore</code></strong></p>
      
      <p><em>не добавлять указанные файлы и каталоги в архив при экспорте с помощью</em> <strong><code>git&#x000A;archive</code></strong></p>
      
      <h1 id="Закрепленные_сценарии">Закрепленные сценарии</h1>
      
      <p><a href="#Клиентские_закрепленные_сценарии">Клиентские закрепленные сценарии</a></p>
      
      <p><a href="#Сценарии_связанные_с_фиксацией_правок">Сценарии, связанные с фиксацией правок</a></p>
      
      <p><a href="#Сценарии_связанные_с_добавление_патчей">Сценарии, связанные с добавление патчей</a></p>
      
      <p><a href="#Серверные_закрепленные_сценарии">Серверные закрепленные сценарии</a></p>
      
      <p>Файлы с закрепленными сценариями содержатся в каталоге <code>.git/hooks</code>.</p>
      
      <h2 id="Клиентские_закрепленные_сценарии">Клиентские закрепленные сценарии</h2>
      
      <p><em>пусто</em></p>
      
      <h2 id="Сценарии_связанные_с_фиксацией_правок">Сценарии, связанные с фиксацией правок</h2>
      
      <p><strong><code>pre-commit</code></strong></p>
      
      <p>Запускается сразу же после команды <code>git commit</code> и перед запуском текстового
      редактора. Если данный сценарий возвращает „0“ (<code>exit 0</code>), то после него будет
      запущен текстовый редактор, если „1“ (<code>exit 1</code>), то фиксация правки будет
      отменена.</p>
      
      <p><strong><code>prepare-commit-msg</code></strong></p>
      
      <p>Запускается перед запуском текстового редактора, но сразу же после создания
      текстового сообщения по умолчанию. Позволяет изменять текстовое сообщение по
      умолчанию. Имеет три аргумента:</p>
      
      <p><code>$*[0]</code> — файл с текстовым сообщением по умолчанию;</p>
      
      <p><code>$*[1]</code> — тип правки <code>{commit | template | squash}</code>;</p>
      
      <p><code>$*[2]</code> — хэш правки.</p>
      
      <p><strong><code>commit-msg</code></strong></p>
      
      <p>Выполняется после закрытия текстового редактора и перед фиксацией правки. Может
      быть использован для проверки журнальной записи на соответствие некоторым
      критериям. Имеет один аргумент:</p>
      
      <p><code>$*[0]</code> — файл с текстовым сообщением.</p>
      
      <p><strong><code>post-commit</code></strong></p>
      
      <p>Запускается после успешной фиксации правки.</p>
      
      <h2 id="Сценарии_связанные_с_добавление_патчей">Сценарии, связанные с добавление патчей</h2>
      
      <p><strong><code>applypatch-msg</code></strong></p>
      
      <p>Запускается перед добавлением патча командой <code>git am</code>. Если сценарий возвратит
      „1“ (<code>exit 1</code>), то патч добавлен не будет, если „0“ (<code>exit 0</code>), то патч будет
      добавлен. Имеет один аргумент:</p>
      
      <p><code>$*[0]</code> — временный файл, содержащий журнальную запись.</p>
      
      <p><strong><code>pre-applypatch</code></strong></p>
      
      <p>Запускается перед добавлением патча командой <code>git am</code>. Позволяет проверить
      некоторые изменения в файлах проекта. Если сценарий возвратит „1“ (<code>exit 1</code>), то
      изменения в файлах будут выставлены, если „0“ (exit 0), то патч будет добавлен.
      Не имеет аргументов.</p>
      
      <p><strong><code>post-applypatch</code></strong></p>
      
      <p>Запускается по завершению добавления патча командой <code>git am</code>. Не позволяет
      проводить какие-либо проверки и отменять обновление проекта. Не имеет
      аргументов.</p>
      
      <h2 id="Сценари_связанные_с_перебазированием_слиянием_и_выпиской">Сценарии, связанные с перебазированием, слиянием и выпиской</h2>
      
      <p><strong><code>pre-rebase</code></strong></p>
      
      <p>Запускается перед перебазированием. Позволяет проверить некоторые условия перед
      этой операцией. Если сценарий возвратит „1“ (<code>exit 1</code>), то перебазирование не
      будет осуществлено, если „0“ (<code>exit 0</code>), то будет. Может иметь два, либо один
      аргумент:</p>
      
      <p><code>$*[0]</code> — базовая ветвь;</p>
      
      <p><code>$*[1]</code> — целевая ветвь (nil, в случае, если перебазируется текущая ветвь).</p>
      
      <p><strong><code>post-merge</code></strong></p>
      
      <p>Запускается после успешного слияния. Имеет один аргумент:</p>
      
      <p><code>$*[0]</code> — флаг, указывающий на тип слияния (0 — обычное, 1 ­ слияние через
      сжатие).</p>
      
      <p><strong><code>post-checkout</code></strong></p>
      
      <p>Запускается после выписки. Имеет три аргумента:</p>
      
      <p><code>$*[0]</code> — полный хэш последней правки в текущей ветви;</p>
      
      <p><code>$*[1]</code> — полный хэш последней правки в выписанной ветви;</p>
      
      <p><code>$*[2]</code> — флаг, указывающий на тип выписки (0 — выписка файла, 1 — выписка
      ветви).</p>
      
      <h2 id="Серверные_закрепленные_сценарии">Серверные закрепленные сценарии</h2>
      
      <p>Серверные закрепленные сценарии содержатся в каталоге <code>hooks/</code> в удаленном репозитории.</p>
      
      <p><strong><code>pre-receive</code></strong></p>
      
      <p>Запускается после получения обновлений от клиента, перед добавлением этих
      обновлений в репозиторий. Будет выполнен один раз, вне зависимости от того,
      сколько ветвей предполагается обновить. Позволяет отклонять обновления
      удаленного репозитория. Если сценарий возвращает „1“ (<code>exit 1</code>), то обновления
      не произойдет, если „0“ (<code>exit 0</code>), то обновление пройдет успешно. Не имеет
      аргументов.</p>
      
      <p><strong><code>update</code></strong></p>
      
      <p>Запускается после получения обновлений от клиента, перед добавлением этих
      обновлений в репозиторий. Будет выполнен столько раз, сколько ветвей
      предполагается обновить. Позволяет отклонять обновление определенных ветвей.
      Если сценарий возвращает „1“ (<code>exit 1</code>), то обновления не произойдет, если „0“
      (<code>exit 0</code>), то обновление пройдет успешно. Имеет три аргумента:</p>
      
      <p><code>$*[0]</code> — полное имя ветви, предполагаемой для обновления;</p>
      
      <p><code>$*[1]</code> — хэш текущей правки для данной ветви;</p>
      
      <p><code>$*[2]</code> — хэш последней правки для данной ветви.</p>
      
      <p><strong><code>post-receive</code></strong></p>
      
      <p>Запускается после добавления обновлений, полученных от клиента. Будет выполнен
      один раз, вне зависимости от того сколько ветвей было обновлено. Не имеет
      аргументов.</p>
      
      <h1 id="Выставление">Выставление</h1>
      
      <p><strong><code>git add</code></strong> <em><code>file</code></em></p>
      
      <p><em>выставить файл для фиксации правок</em></p>
      
      <p><strong><code>git add -i</code></strong></p>
      
      <p><em>выставить желаемые файлы посредством их выбора в интерактивном режиме</em></p>
      
      <p>Запустится интерактивная утилита. Потребуется выбрать файлы.</p>
      
      <p><strong><code>git add -p</code></strong></p>
      
      <p><em>выставить файлы путем последовательного выбора или отката желаемых правок в
      интерактивном режиме</em></p>
      
      <p>Запуститися интерактивная утилита. Потребуется выбрать <em>правки</em>.</p>
      
      <p><strong><code>git add -e</code></strong></p>
      
      <p><em>выставить файлы путем выбора или отката желаемых правок в текстовом редакторе</em></p>
      
      <p>Запустится текстовый редактор. Потребуется удалить ненужные правки путем
      непосредственного исключения их из текста загруженного документа.</p>
      
      <p><strong><code>git reset HEAD</code></strong> <em><code>file</code></em></p>
      
      <p><em>снять выставленный файл</em></p>
      
      <p>Файл должен находиться в <a href="#staged_area">индексе</a>.</p>
      
      <p><strong><code>git checkout --</code></strong> <em><code>file</code></em></p>
      
      <p><em>отменить правки в указанном файле</em></p>
      
      <p>Файл должен находиться в <a href="#unstaged_area">рабочей области</a>.</p>
      
      <p><strong><code>git rm</code></strong> <em><code>file</code></em></p>
      
      <p><em>выставить файл для удаления</em></p>
      
      <p>Файл должен быть <a href="#tracked_file">включен</a> в репозиторий. В <a href="#untracked_file">противном случае</a>, следует использовать
      средства операционной системы для удаления файла (e. g. <code>rm file</code>).</p>
      
      <p><strong><code>git rm --cached</code></strong> <em><code>file</code></em></p>
      
      <p><em>отменить добавление нового неотслеживаемого файла в индекс и вернуть его в
      рабочую область</em></p>
      
      <p><strong><code>git mv</code></strong> <em><code>old_name</code></em> <em><code>new_name</code></em></p>
      
      <p><em>выставить файл для переименования</em></p>
      
      <h1 id="Откладывание_правок">Откладывание правок</h1>
      
      <p><strong><code>git stash</code></strong></p>
      
      <p><em>отложить сделанные правки</em></p>
      
      <p><strong><code>git stash list</code></strong></p>
      
      <p><em>вывести список отложенных правок</em></p>
      
      <p><strong><code>git stash show stash@{</code></strong><em><code>n</code></em><strong><code>}</code></strong></p>
      
      <p><em>вывести краткие сведения об указанной отложенной правке</em></p>
      
      <p><strong><code>git stash show -p stash@{</code></strong><em><code>n</code></em><strong><code>}</code></strong></p>
      
      <p><em>вывести подробные сведения об указанной отложенной правке</em></p>
      
      <p><strong><code>git stash apply stash@{</code></strong><em><code>n</code></em><strong><code>}</code></strong></p>
      
      <p><em>добавить n-ую отложенную правку</em></p>
      
      <p><strong><code>git drop stash@{</code></strong><em><code>n</code></em><strong><code>}</code></strong></p>
      
      <p><em>удалить n-ую отложенную правку</em></p>
      
      <p><strong><code>git stash branch</code></strong> <em><code>name</code></em> <strong><code>stash@{</code></strong><em><code>n</code></em><strong><code>}</code></strong></p>
      
      <p><em>создать ветвь из отложенной правки и удалить последнее</em></p>
      
      <h1 id="Фиксация_правок">Фиксация правок</h1>
      
      <p><strong><code>git commit</code></strong></p>
      
      <p><em>зафиксировать изменения для всех выставленных файлов</em></p>
      
      <p><strong><code>git commit -m</code></strong> <em><code>message</code></em></p>
      
      <p><em>зафиксировать изменения одновременно с добавлением журнальной записи</em></p>
      
      <p><strong><code>git commit</code></strong> <em><code>file</code></em></p>
      
      <p><em>зафиксировать изменения только для указанного файла, вне зависимости от того, является он выставленным или нет</em></p>
      
      <p><strong><code>git commit -a</code></strong></p>
      
      <p><em>зафиксировать изменения для всех файлов, как выставленных так и не выставленных</em></p>
      
      <h1 id="Исправление_и_откат_сделанных_передач">Исправление и откат сделанных передач</h1>
      
      <pre><code>git commit --amend -m &lt;новая_запись&gt; - изменить журнальную запись для последней передачи, а так же добавить выставленные изменения в последнюю передачу, если таковые имеются.&#x000A;&#x000A;git commit --amend -C HEAD - добавить выставленные изменения в уже совершенную передачу.&#x000A;&#x000A;git commit --amend -a -C HEAD - добавить невыставленные изменения в уже совершенную передачу.&#x000A;&#x000A;git revert &lt;хэш&gt; - осуществить передачу, отменяющую изменения в указанной передачи. Если необходимо осуществить отменяющую передачу не для последней передачи, то нужно последовательно выполнить данный тип передачи несколько раз, начиная с последней передачи.&#x000A;  git revert -n &lt;хэш&gt; - выставить отмененные изменения. При пакетной отмене, можно использовать идиому: git revert -n HEAD; git revert -n HEAD^; git revert -n HEAD^^ и т. д.&#x000A;  git revert --no-edit &lt;хэш&gt; - не запускать редактор при выполнении отменяющей передачи. В этом случае в качестве журнального сообщения будет присутствовать стандартная запись.&#x000A;&#x000A;git reset &lt;хэш&gt; - переместится в истории изменений до указанной передачи, удалив все последующие, не выставляя все осуществленные изменения.&#x000A;&#x000A;  git reset --soft &lt;хэш&gt; - переместиться в истории изменений до указанной передачи, удалив все последующие, выставив все осуществленные изменения.&#x000A;&#x000A;  git reset --hard &lt;хэш&gt; - переместиться в истории изменений до указанной передачи, удалив все последующие.&#x000A;&#x000A;git filter-branch --tree-filter 'rm -f &lt;файл&gt;' &lt;ветвь&gt; - удалить указанный файл во всех передачах ветви. Будет создана резервная копия. Удалить её можно следующей командой.&#x000A;&#x000A;  git update-ref -d &lt;ветвь&gt; &lt;хэш&gt;&#x000A;&#x000A;Если затем попытаться повторно удалить некий файл уже из другой ветви, то команда возвратит ошибку, сообщающую о невозможности перезаписать резервную копию. Для того, чтобы форсировать перезапись нужно добавить опцию -f к команде.&#x000A;&#x000A;  git filter-branch -f --tree-filter 'rm -f &lt;файл&gt;' &lt;ветвь&gt;&#x000A;&#x000A;  git filtrer-branch --tree-filter 'rm -f &lt;файл&gt;' -- --all - удалить указанный файл во всех передачах всех ветвей.&#x000A;</code></pre>
      
      <h1 id="Журналирование">Журналирование</h1>
      
      <p><strong><code>git log</code></strong></p>
      
      <p><em>вывести список всех сделанных правок</em></p>
      
      <p><strong><code>git log --format=</code></strong><em><code>format_string</code></em></p>
      
      <p><em>задать пользовательский формат вывода</em></p>
      
      <p>Cписок символов форматирования:</p>
      
      <p><code>%h</code> - укороченный хэш, идентифицирующий правку;</p>
      
      <p><code>%s</code> - загловок журнальной записи;</p>
      
      <p><code>%b</code> - содержимое журнальной записи;</p>
      
      <p><code>%n</code> - новая строка.</p>
      
      <p><strong><code>git log -</code></strong><em><code>number</code></em></p>
      
      <p><em>ограничить перечень выводимых правок заданным числом</em></p>
      
      <p><strong><code>git log</code></strong> <em><code>hash</code></em></p>
      
      <p><em>не отображать правки после заданной указанным хэшем</em></p>
      
      <p><strong><code>git log</code></strong> <em><code>old_hash</code></em><strong><code>..</code></strong><em><code>[ new_hash ]</code></em></p>
      
      <p><em>вывести список правок в заданном интервале</em></p>
      
      <p>Правка, соответствующая нижней границе не будет включена в вывод. Верхняя
      граница может быть опущена. В этом случае, таковой будет считаться последняя
      сделанная правка.</p>
      
      <p><strong><code>git log --oneline --left-right --boundary </code></strong> <em><code>left_branch</code></em><strong><code>...</code></strong><em><code>right_branch</code></em></p>
      
      <p><em>вывести список правок для двух ветвей с общей правкой</em></p>
      
      <p>В выводе под каждую правку будет выделена одна строка (<code>--oneline</code>). Вывод будет
      содержать правки обоих ветвей, а так же общую правку-родителя (<code>--boundary</code>).
      Информация будет выведена в один столбик. Каждую запись будет предварять либо
      стрелка влево, либо стрелка вправо, в зависимости от того куда была внесена
      правка, в левую или в правую ветвь (<code>--left-right</code>). Общая правка будет помечена
      знаком дефис (<code>-</code>).</p>
      
      <p><strong><code>git log</code></strong> <em><code>{</code></em> <strong><code>--since=</code></strong> <em><code>|</code></em> <strong><code>--until=</code></strong> <em><code>}datetime</code></em></p>
      
      <p><em>вывести список правок с/до указанной даты-времени</em></p>
      
      <p>Формат даты-времени может быть разным. Например:</p>
      
      <p><code>12012019</code> — 12 декабря 2019 года;</p>
      
      <p><code>1201</code> — 12 декабря текущего года;</p>
      
      <p><code>12.01.2019 13:00:04</code> — 12 декабря 2019 года 13:00:04.</p>
      
      <p><strong><code>git log -p</code></strong></p>
      
      <p><em>вывести список правок вместе со сделанным изменениями</em></p>
      
      <p><strong><code>git log --all --graph</code></strong></p>
      
      <p><em>отобразить историю правок во всех ветвях в виде графов</em></p>
      
      <p><strong><code>git log --</code></strong> <em><code>file</code></em></p>
      
      <p><em>отобразить историю правок только для указанного файла</em></p>
      
      <p><strong><code>git log</code></strong> <em><code>branch</code></em> <em><code>[</code></em> <strong><code>--not</code></strong> <em><code>base_branch</code></em> <em><code>|</code></em> <strong><code>^</code></strong> <em><code>base_branch</code></em> <em><code>]</code></em></p>
      
      <p><em>отобразить историю правок для указанной ветви</em></p>
      
      <p>Посредство опции <code>--not</code> имеется возможность исключить из вывода правки,
      сделанные в ветви на которой основана указанная ветвь.</p>
      
      <p><strong><code>git log --decorate=</code></strong><em><code>format</code></em></p>
      
      <p><em>задать формат отображения <a href="#ссылка">ссылок</a></em></p>
      
      <p>Перечень возможных значений:</p>
      
      <p><code>short</code> — укороченный формат: „<code>master</code>“, „<code>origin/master</code>“;</p>
      
      <p><code>full</code> — полный формат: „<code>refs/heads/master</code>“, „<code>refs/remotes/origin/master</code>“;</p>
      
      <p><code>auto</code> — при выводе на терминал <code>short</code>, иначе — <code>full</code>;</p>
      
      <p><code>no</code> — не отображать.</p>
      
      <p><strong><code>git rev-parse</code></strong> <em><code>reference</code></em></p>
      
      <p><em>вывести полный хэш для указанного объекта</em></p>
      
      <p>В качестве объектов могут выступать правки или аннотированные метки. Хэш
      аннотированной метки это отдельный хэш, не зависимый от хэша промаркированной
      правки.</p>
      
      <p><strong><code>git show</code></strong> <em><code>reference</code></em></p>
      
      <p><em>вывести подробную информацию об объекте по ссылке</em></p>
      
      <p>В качестве объектов могут выступать правки или аннотированные метки.</p>
      
      <h1 id="Просмотр_изменений">Просмотр изменений</h1>
      
      <p><strong><code>git diff</code></strong></p>
      
      <p><em>просмотреть изменения во всех файлах относительно индекса</em></p>
      
      <p><strong><code>git diff --staged</code></strong></p>
      
      <p><em>просмотреть изменения между выставленными файлами и файлами в репозитории</em></p>
      
      <p><strong><code>git diff --text</code></strong></p>
      
      <p><em>рассматривать двоичные файлы как текстовые</em> (по умолчанию, git игнорирует двоичные файлы и не выводит изменения в них)</p>
      
      <p><strong><code>git diff --stat</code></strong></p>
      
      <p><em>вывести сводный отчет по сделанным изменениям</em></p>
      
      <p><strong><code>git diff --check</code></strong></p>
      
      <p><em>проверить файл на наличие завершающих пробелов</em></p>
      
      <p><strong><code>git diff -U</code></strong><em><code>number</code></em></p>
      
      <p><em>установить количество отображаемых строк до и после изменённой строки</em></p>
      
      <p><strong><code>git diff</code></strong> <em><code>hash</code></em></p>
      
      <p><em>просмотреть изменения во всех файлах относительно указанной правки</em></p>
      
      <p><strong><code>git diff</code></strong> <em><code>hash</code></em> <em><code>file</code></em></p>
      
      <p><em>просмотреть изменения в конкретном файле относительно указанной правки</em></p>
      
      <p><strong><code>git diff</code></strong> <em><code>tag..tag</code></em></p>
      
      <p><em>просмотреть изменения в указанном интервале правок</em></p>
      
      <p><strong><code>git diff</code></strong> <em><code>base_branch..target_branch</code></em></p>
      
      <p><em>просмотреть изменения между целевой ветвью и общим предком базовой и целевой ветвей</em></p>
      
      <p><strong><code>git difftool</code></strong></p>
      
      <p><em>просмотреть изменения в специализированной программе</em></p>
      
      <p><strong><code>git difftool -y</code></strong></p>
      
      <p><em>не выводить подтверждающий запрос при запуске программы просмотра изменений</em></p>
      
      <p><strong><code>git blame</code></strong> <em><code>file</code></em></p>
      
      <p><em>просмотреть изменения в файле с включением в вывод хэша, автора, даты и прочей информации</em></p>
      
      <p><strong><code>git blame -L</code></strong> <em><code>starting_line</code></em><strong><code>,</code></strong><em><code>{ ending_line | </code></em> <strong><code>-</code></strong><em><code>offset</code></em> <em><code>|</code></em> <strong><code>+</code></strong><em><code>offset</code></em> <em><code>}</code></em> <em><code>file</code></em></p>
      
      <p><em>отобразить только указанные строки в просматриваемом файле</em></p>
      
      <p>Интервал задается указанием номера начальной строки и (опционально) номером
      конечной строки или количеством строк до или после начальной.</p>
      
      <p><strong><code>git blame</code></strong> <em><code>hash{</code></em> <strong><code>^</code></strong><em><code>[offset] |</code></em> <strong><code>~</code></strong><em><code>[offset] }</code></em> <strong><code>--</code></strong> <em><code>file</code></em></p>
      
      <p><em>просмотреть изменения в файле до указанной правки и не включать все последующие</em></p>
      
      <p>Правка идентифицируется хэшем или отклонением от правки с указанным хэшем (<code>^</code> —
      „первый прямой предок указанной“ (если прямых предков несколько), <code>^n</code> — „n-й
      прямой предок указанной“, <code>~n</code> — „указанная, минус n“).</p>
      
      <p><strong><code>git blame</code></strong> <em><code>hash</code></em><strong><code>..</code></strong><em><code>hash</code></em> <strong><code>--</code></strong> <em><code>file</code></em></p>
      
      <p><em>просмотреть изменения в указанном интервале правок</em></p>
      
      <h1 id="Ветвление">Ветвление</h1>
      
      <pre><code>git branch - показать все текущие ветви и отметить рабочую.&#x000A;  git branch -v - показать все ветви, отметить текущую и вывести последнюю передачу для каждой ветви.&#x000A;  git branch -r - показать все ветви в удаленном репозитории.&#x000A;  git branch &lt;имя_ветви&gt; &lt;имя_родительской_ветви&gt; - создать ветвь.&#x000A;  git branch &lt;имя_новой_ветви&gt; &lt;имя_метки&gt; - восстановить ветвь с указанной метки.&#x000A;  git branch -d &lt;имя_ветви&gt; - удалить ветвь. Ветвь должна быть слита.&#x000A;    git branch -rd &lt;имя_ветви&gt; - удалить удаленную ветвь.&#x000A;  git branch -D &lt;имя_ветви&gt; - удалить ветвь вне зависимости от того, слита она или нет.&#x000A;  git branch -m &lt;прежнее_имя&gt; &lt;новое_имя&gt; - переименовать ветвь.&#x000A;&#x000A;git checkout &lt;имя_ветви&gt; - выписать указанную ветвь.&#x000A;  git checkout -b &lt;имя_новой_ветви&gt; &lt;имя_родительской_ветви&gt; - создать новую ветвь и сразу же переключиться на неё.&#x000A;</code></pre>
      
      <h1 id="Слияние">Слияние</h1>
      
      <pre><code>git merge &lt;имя_ветви&gt; - осуществить прямое слияние текущей ветви с указанной.&#x000A;  git merge --no-commit &lt;имя_ветви&gt; - выствить слияние.&#x000A;  git merge --squash &lt;имя_ветви&gt; - выставить объединенные передачи указанной ветви для текущей.&#x000A;  git cherry-pick &lt;укороченный_дайджест&gt; - осуществить передачу, помеченную дайджестом, для текущей ветви.&#x000A;  git cherry-pick {-n | --no-commit} &lt;укороченный_дайджест&gt; - выставить передачу, помеченную дайджестом, для текущей ветви.&#x000A;&#x000A;git mergetool &lt;программа_сравнения&gt; - использовать программу сравнения для разрешения конфликтов слияния.&#x000A;&#x000A;git merge-base &lt;ветвь_1&gt; &lt;ветвь_2&gt; - найти общего предка между двумя ветвями.&#x000A;</code></pre>
      
      <h1 id="Перебазирование">Перебазирование</h1>
      
      <pre><code>git rebase &lt;базовая_ветвь&gt; &lt;целевая_ветвь&gt; - перебазировать целевую ветвь в конец базовой.&#x000A;  git rebase &lt;ветвь&gt; - перебазировать текущую ветвь в конец указанной.&#x000A;&#x000A;git rebase --onto &lt;базовая_ветвь&gt; &lt;ветвь_посредник&gt; &lt;целевая_ветвь&gt; - перебазировать целевую ветвь в конец базовой, исключая предка в ветви посреднике.&#x000A;  git reabase --onto &lt;базовая_ветвь&gt; &lt;ветвь_посредник&gt; - перебазировать текущую ветвь в конец базовой, исключая предка в ветви посреднике. &#x000A;&#x000A;git rebase -i &lt;хэш&gt; - войти в интерактивный режим для изменения порядка передач.&#x000A;</code></pre>
      
      <h1 id="Метки">Метки</h1>
      
      <pre><code>git tag &lt;метка&gt; &lt;имя_ветви&gt; - добавить легковесную метку для указанной ветви.&#x000A;  git tag &lt;метка&gt; &lt;укороченный_дайджест_передачи&gt; - установить метку для одной из предыдущих передач.&#x000A;  git tag -a &lt;метка&gt; -m &lt;описание&gt; - добавить аннотированную метку для текущей ветви.&#x000A;  git tag - возвратить список меток.&#x000A;  git tag -d &lt;метка&gt; - удалить указанную метку.&#x000A;</code></pre>
      
      <h1 id="Работа_с_удаленными_репозиториями">Работа с удаленными репозиториями</h1>
      
      <pre><code>git clone &lt;URL&gt; - клонировать репозиторий в локальный каталог.&#x000A;&#x000A;git remote add &lt;имя&gt; &lt;URL&gt; - добавить удаленный репозиторий.&#x000A;git remote -v - просмотр всех удаленных репозиториев и их URL.&#x000A;git remote rm &lt;имя&gt; - удалить указанный удаленный репозиторий.&#x000A;&#x000A;git fetch {&lt;url&gt; | &lt;локальное_имя&gt;} - скачать объекты из указанного удаленного репозитория и не сливать их с имеющимися в локальном репозитории.&#x000A;&#x000A;git pull {&lt;url&gt; | &lt;локальное_имя&gt;} - скачать объекты из указанного удаленного репозитория и слить их с имеющимися в локальном репозитории.&#x000A;&#x000A;git push [&lt;имя_удаленного_репозитория&gt;] - обновить удаленный репозиторий.&#x000A;  git push --dry-run - имитировать обновление репозитория.&#x000A;  git push &lt;репозиторий&gt; &lt;ветвь&gt; - обновить удаленный репозиторий, добавив в него только указанную ветвь.&#x000A;  git push &lt;репозиторий&gt; &lt;ветвь&gt;:&lt;имя_в_удаленном_репозитории&gt; - обновить удаленный репозиторий, добавив в него указанную ветвь, но сохранив её под другим именем.&#x000A;  git push &lt;удаленный_репозиторий&gt; :&lt;удаляемая_ветвь&gt; - удалить указанную ветвь из удаленного репозитория.&#x000A;  git push -f - осуществить настойчивое обновление.&#x000A;  git push --tags - добавить в репозиторий все имеющиеся метки.&#x000A;&#x000A;  git request-pull &lt;начальная_ссылка&gt; &lt;url_репозитория&gt; [&lt;конечная_ссылка&gt;] - вывысти на экран сводную статистику по передачам, ожидающим вытягивания со стороны менеджера.&#x000A;</code></pre>
      
      <h1 id="Субмодули">Субмодули</h1>
      
      <pre><code>git submodule - просмотреть субмодули.&#x000A;  git submodule add &lt;репозиторий&gt; &lt;имя&gt; - создать директорую с указанным именем и добавить в неё указанный репозиторий.&#x000A;  git submodule init &lt;имя&gt; - инициализировать (добавить запись о субмодуле в .git/config) указанный субмодуль.&#x000A;  git submodule update &lt;имя&gt; - обновить субмодуль.&#x000A;</code></pre>
      
      <h1 id="Архивирование">Архивирование</h1>
      
      <pre><code>git archive --format=&lt;tar | zip&gt; --prefix=&lt;имя&gt;/ &lt;ветвь&gt; - поместить все файлы проекта в директорию с указанным именем и создать архив указанного формата.&#x000A;&#x000A;  git archive --format=tar --prefix=&lt;имя&gt;/ &lt;ветвь&gt; | gzip &gt; &lt;имя&gt;.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата tar и сжать этот архив, сохраняя в файле .tar.gz.&#x000A;&#x000A;  git archive --prefix=&lt;имя&gt;/ &lt;ветвь&gt; | gzip &gt; `git describe --tags master`.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата по умолчанию (tar) и сжать этот архив, сохраняя в файле с именем являющимся выводом команды git-describe, добавляя расширение .tar.gz.&#x000A;&#x000A;    git describe --tags &lt;ветвь&gt; - показать самую последнюю созданную метку, учитывая неаннотированные метки. Вывод команды имеет следующий формат: &lt;имя_тэга&gt;-&lt;количество_сделанных_передач&gt;-g&lt;хэш_последней_передачи&gt;. "g" в выводе означает, что используется VCS git.&#x000A;</code></pre>
      
      <h1 id="Патчи">Патчи</h1>
      
      <pre><code>git format-patch [&lt;начальная_передача&gt; | &lt;начальная_передача&gt;..&lt;конечная_передача&gt;] - подготовить файлы с патчами для отправки по электронной почте. Использовать либо все передачи начиная с начальной до текущей, либо все передачи в указанном интервале.&#x000A;&#x000A;  git format-patch -o &lt;директория_вывода&gt; - подготовить файлы патчей и сохранить их в указанной директории.&#x000A;&#x000A;  git format-patch --stdout - подготовить файлы патчей и вывести их содержимое в консоль.&#x000A;&#x000A;git apply &lt;файл_патча&gt; - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданные с помощью следующих команд.&#x000A;&#x000A;  $ git diff &lt;старт-метка&gt;..&lt;финиш-метка&gt; &gt; &lt;имя&gt;.patch&#x000A;  $ git log -p &lt;старт-метка&gt;..&lt;финиш-метка&gt; &gt; &lt;имя&gt;.patch&#x000A;&#x000A;git am {&lt;mbox-файл&gt; | &lt;файл_патча&gt;} - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданный с помощью следующей команды.&#x000A;&#x000A;  $ git format patch &lt;старт-метка&gt;..&lt;финиш_метка&gt; -о &lt;директория&gt;&#x000A;&#x000A;  git am -i {&lt;mbox-файл&gt; | &lt;файл-патча&gt;} - добавить изменеия в файлы проекта в интерактивном режиме.&#x000A;&#x000A;  git am -3 {&lt;mbox-файл&gt; | &lt;файл-патча&gt;} - добавить изменения в файлы проекта. При возникновении конфлика добавить конфликтные маркеры в файлы с конфликтами.&#x000A;</code></pre>
      
      <h1 id="Отправка_патчей_по_электронной_почте">Отправка патчей по электронной почте</h1>
      
      <p>Для отправки почты необходимо установить пакет sendmail.</p>
      
      <pre><code>git send-email --from=&lt;адрес_отправителя&gt; --to=&lt;адрес_получателя&gt; {&lt;список_файлов&gt; | &lt;директория&gt;} - отправить на указанный адрес либо перечисленные файлы патчей, либо все файлы в указанной директории.&#x000A;&#x000A;   Настройка git send-email&#x000A;  --------------------------&#x000A;    # ~/.gitconfig&#x000A;    [sendemail]&#x000A;      smtpserver = &lt;адрес_smtp-сервера&gt; (smtp.gmail.com)&#x000A;      smtpserverport = &lt;порт_smpt-сервера&gt; ({587 | 465})&#x000A;      smtpencryption = &lt;криптографический_протокол&gt; ({tls | ssl})&#x000A;      smtpuser = &lt;логин&gt; (login@gmail.com)&#x000A;      smtppass = &lt;пароль&gt; (password)&#x000A;      from = &lt;адрес_отправителя&gt;&#x000A;      to = &lt;адрес_получателя&gt;&#x000A;      confirm = {always | never}&#x000A;&#x000A;git format-patch --stdout {&lt;начальная_передача&gt; | &lt;интервал&gt;} | git imap-send - загрузить файлы патчей в директорию с черновиками на почтовом сервере.&#x000A;&#x000A;   Настройка git imap-send&#x000A;  -------------------------&#x000A;    # ~/.gitconfig&#x000A;    [imap]&#x000A;      folder = &lt;директория_с_черновиками&gt; ([Gmail]/Черновики)&#x000A;      host = &lt;адрес_почтового_сервера&gt; ({imaps:// | imap://}imap.gmail.com)&#x000A;      port = &lt;порт_почтового_сервера&gt; ({993 | 143})&#x000A;      user = &lt;логин&gt; (login@gmail.com)&#x000A;      pass = &lt;пароль&gt; (password)&#x000A;      sslverify = &lt;логическое_значение&gt; ({false | true})&#x000A;</code></pre>
      
      <h1 id="Восстановление_и_очистка">Восстановление и очистка</h1>
      
      <pre><code>git gc - удалить ненужные файлы и произвести оптимизацию локального репозитория.&#x000A;&#x000A;git reflog - отобразить журнал изменений.&#x000A;</code></pre>
      
      <h1 id="Пошаговый_поиск_проблемных_передач">Пошаговый поиск проблемных передач</h1>
      
      <pre><code>git bisect start &lt;проблемная_передача&gt; &lt;беспроблемная_передача&gt; - начать пошаговый поиск в указанном интервале.&#x000A;&#x000A;  git bisect bad  - отметить передачу как проблемную.&#x000A;  git bisect good - отметить передачу как беспроблемную.&#x000A;&#x000A;  git bisect reset - закончить пошаговый поиск.&#x000A;&#x000A;    git bisect reset &lt;метка&gt; - закончить пошаговый поиск и установить указатель HEAD на отмеченную передачу.&#x000A;</code></pre>
      
      <h1 id="Gitosis">Gitosis</h1>
      
      <h2 id="Порядок_установки_менеджера_репозиториев_Gitosis">Порядок установки менеджера репозиториев Gitosis</h2>
      
      <p>\1. На удаленной машине создать пользователя git.</p>
      
      <pre><code># adduser \&#x000A;&gt; --system \&#x000A;&gt; --group \&#x000A;&gt; --disabled-password \&#x000A;&gt; --shell /bin/sh \&#x000A;&gt; --home /home/git \&#x000A;&gt; git&#x000A;</code></pre>
      
      <p>\2. На локальной машине создать публичный ключ для использования вместе с SSH.</p>
      
      <pre><code>$ ssh-keygen -t rsa&#x000A;</code></pre>
      
      <p>Если не указывать пароль для ключа, то при подключении к SSH-серверу система не будет требовать аутентификации. Обе части ключа (публичная и частная) будут размещены в директории ~/.ssh</p>
      
      <p>\3. Скопировать публичную часть ключа (&lt;имя_ключа&gt;.pub) на сервер в директорию /путь/к/публичному/ключу.</p>
      
      <p>\4. Инициализировать Gitosis на удаленной машине.</p>
      
      <pre><code># su git -c 'gitosis-init &lt; /путь/к/публичному/ключу'&#x000A;</code></pre>
      
      <p>\4.1 Добавить алиас для IP-адреса удаленной машины в файл /etc/hosts локальной машины.</p>
      
      <pre><code>$ vim /etc/hosts&#x000A;$ cat /etc/hosts&#x000A;...&#x000A;192.168.1.14 pavel-server&#x000A;...&#x000A;</code></pre>
      
      <h2 id="Настройка_Gitosis">Настройка Gitosis</h2>
      
      <p>1) Склонировать конфигурацоный репозиторий Gitosis на локальную машину. Если для пользователя был установлен пароль, то он будет запрошен.</p>
      
      <pre><code>$ git clone git@pavel-server:gitosis-admin.git&#x000A;</code></pre>
      
      <p>или</p>
      
      <pre><code>$ git clone ssh://git@pavel-server/gitosis-admin.git&#x000A;</code></pre>
      
      <p>2) Перейти в директорию gitosis-admin.git и открыть файл gitosis.conf.</p>
      
      <pre><code>$ cd gitosis-admin&#x000A;$ vim gitosis.conf&#x000A;</code></pre>
      
      <p>3.1) Для настройки доступа к конфигурации Gitosis добавить нового пользователя в графу ‘members’ секции ‘[group gitosis-admin]’. Для добавления нескольких пользователей, необходимо перечислить их в данной графе, разделяя пробелами. Не стоит добавлять лишние пробелы в конфигурационный файл во избежании возникновения ошибки интерпретатора языка Perl при отправке изменений на сервер*.</p>
      
      <pre><code>$ cat gitosis.conf&#x000A;[group gitosis-admin]&#x000A;writable = gitosis-admin&#x000A;members = &lt;пользователь_1&gt; &lt;пользователь_2&gt; ...&#x000A;</code></pre>
      
      <p>*Hо не.</p>
      
      <pre><code>[group gitosis-admin]&#x000A;  writable = gitosis-admin&#x000A;  members  = &lt;пользователь_1&gt; &lt;пользователь_2&gt; ...&#x000A;</code></pre>
      
      <p>3.2) Для добавления нового частного репозитория добавить новую секцию.</p>
      
      <pre><code>[group &lt;группа_чтение-запись&gt;]&#x000A;writable = &lt;репозиторий_а&gt;&#x000A;members = &lt;пользователь_1&gt; &lt;пользователь_2&gt; ...&#x000A;</code></pre>
      
      <p>Все перечисленные пользователи будут иметь право доступа и записи в созданный репозиторий.</p>
      
      <pre><code>[group &lt;группа_только_чтение&gt;]&#x000A;readonly = &lt;репозиторий_а&gt;&#x000A;members = &lt;пользователь_3&gt; &lt;пользователь_4&gt; ...&#x000A;</code></pre>
      
      <p>Здесь, все перечисленные пользователи смогут только клонировать указанный репозиторий. Они не будут иметь право записи.</p>
      
      <pre><code>[repo &lt;репозиторий_а&gt;]&#x000A;daemon = yes&#x000A;</code></pre>
      
      <p>Добавив данную секцию можно открыть публичный доступ к указанному репозиторию. Для того, чтобы пользователи могли скачивать этот репозиторий необходимо запустить git-daemon на удаленной машине.</p>
      
      <pre><code># su git -c "git daemon --base-path=&lt;git-home&gt;/repositories"&#x000A;</code></pre>
      
      <p>Таким образом будет открыт общий доступ к данному репозиторию с правом чтения, но не записи. Непривелигированные пользователи будут иметь возможность скачивать репозиторий по протоколу git.</p>
      
      <pre><code>$ git clone git://&lt;хост&gt;/&lt;путь&gt;.git&#x000A;</code></pre>
      
      <p>Например:</p>
      
      <pre><code>$ git clone git://pavel-server/project.git&#x000A;</code></pre>
      
      <h1 id="Примеры">Примеры</h1>
      
      <h2 id="Создание_локального_репозитория">Создание локального репозитория</h2>
      
      <pre><code>1. $ mkdir project; cd project; git init&#x000A;2. $ touch README; git add .; git commit -m 'init'&#x000A;3. $ mkdir ../project.git; git init --bare ../project.git&#x000A;4. $ git remote add origin file://&lt;путь_к_project.git&gt;&#x000A;5. $ git push origin master&#x000A;</code></pre>
      
      <h2 id="Добавление субмодуля">Добавление субмодуля</h2>
      
      <pre><code>1. $ git submodule add &lt;путь&gt; &lt;имя&gt;&#x000A;2. $ git submodule init &lt;имя&gt;&#x000A;</code></pre>
      
      <h2 id="Добавления_субмодуля_в_составе_склонированного_репозитория">Добавления субмодуля в составе склонированного репозитория</h2>
      
      <pre><code>1. $ git submodule init &lt;имя&gt;&#x000A;2. $ git submodule update &lt;имя&gt;&#x000A;</code></pre>
      
      <h2 id="Исправление_журнальной_записи_передачи">Исправление журнальной записи передачи</h2>
      
      <pre><code>1. $ git rebase -i &lt;хэш_родительской_передачи_для_проблемной&gt;&#x000A;2. Откроется текстовый редактор с перечнем передач.&#x000A;3. Сменить метки pick на edit во всех проблемных передачах.&#x000A;4. Сохранить изменения и закрыть редактор.&#x000A;5. $ git commit --amend&#x000A;6. Откроется редактор с текстом журнальной записи.&#x000A;7. Исправить запись, сохранить изменения, закрыть редактор.&#x000A;8. $ git rebase --continue&#x000A;9. Повторить шаги 5-8 для всех проблемных передач.&#x000A;</code></pre>
      
      <h2 id="Разбивка_одной_передачи_на_несколько">Разбивка одной передачи на несколько</h2>
      
      <pre><code>1. $ git rebase -i &lt;метка&gt;&#x000A;2. Откроется текстовый редактор с перечнем передач.&#x000A;3. Сменить метку pick на edit в проблемной передаче.&#x000A;4. $ git reset HEAD^&#x000A;5. Измененный файл окажется в невыставленной области.&#x000A;6. $ git add -e&#x000A;7. Отредактировать файл, добавляя необходимые изменения.&#x000A;8. $ git commit&#x000A;9. Повторить шаги 6-8 для всех изменений.&#x000A;10. $ git rebase --continue&#x000A;</code></pre>
      
      <!-- vim: set textwidth=80 colorcolumn=80: -->
    </main>
    <footer></footer>
  </body>
</html>
