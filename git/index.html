<!DOCTYPE html>
<html lang='ru'>
  <head>
    <meta charset='utf-8'>
    <link href='/summaries/stylesheet.css' rel='stylesheet'>
    <title>Git</title>
  </head>
  <body>
    <header>
      <h1>Git</h1>
    </header>
    <main>
      <h1 id="Содержание">Содержание</h1>
      
      <p><a href="#Конфигурация">Конфигурация</a></p>
      
      <p><a href="#Создание_нового_репозитория">Создание нового репозитория</a></p>
      
      <p><a href="#Атрибуты">Атрибуты</a></p>
      
      <p><a href="#Закрепленные_сценарии">Закрепленные сценарии</a></p>
      
      <p><a href="#Выставление">Выставление</a></p>
      
      <p><a href="#Откладывание_изменений">Откладывание изменений</a></p>
      
      <p><a href="#Передача">Передача</a></p>
      
      <p><a href="#Исправление_и_откат_сделанных_передач">Исправление и откат сделанных передач</a></p>
      
      <p><a href="#Журналирование">Журналирование</a></p>
      
      <p><a href="#Просмотр_изменений">Просмотр изменений</a></p>
      
      <p><a href="#Ветвление">Ветвление</a></p>
      
      <p><a href="#Слияние">Слияние</a></p>
      
      <p><a href="#Перебазирование">Перебазирование</a></p>
      
      <p><a href="#Метки">Метки</a></p>
      
      <p><a href="#Работа_с_удаленными_репозиториями">Работа с удаленными репозиториями</a></p>
      
      <p><a href="#Субмодули">Субмодули</a></p>
      
      <p><a href="#Архивирование">Архивирование</a></p>
      
      <p><a href="#Патчи">Патчи</a></p>
      
      <p><a href="#Отпавка_патчей_по_электронной_почте">Отпавка патчей по электронной почте</a></p>
      
      <p><a href="#Восстановление_и_очистка">Восстановление и очистка</a></p>
      
      <p><a href="#Пошаговый_поиск_проблемных_передач">Пошаговый поиск проблемных передач</a></p>
      
      <p><a href="#Gitosis">Gitosis</a></p>
      
      <p><a href="#Примеры">Примеры</a></p>
      
      <h1 id="Конфигурация">Конфигурация</h1>
      
      <h2 id="Команды_конфигурации">Команды конфигурации</h2>
      
      <p><strong><code>git config --system</code></strong> <em><code>option</code></em> <em><code>value</code></em></p>
      
      <p><em>системная (/etc/gitconfig)</em></p>
      
      <p><strong><code>git config --global</code></strong> <em><code>option</code></em> <em><code>value</code></em></p>
      
      <p><em>глобальная (~/.gitconfig)</em></p>
      
      <p><strong><code>git config</code></strong> <em><code>option</code></em> <em><code>value</code></em></p>
      
      <p><em>локальная (.git/config)</em></p>
      
      <h2 id="Опции">Опции</h2>
      
      <p><strong><code>alias.</code></strong><em><code>old_command</code></em> <em><code>new_command</code></em></p>
      
      <p><em>добавить замену для стандартной команды</em></p>
      
      <p><em>При замене глобальной команды следует поставить „!“ перед заменяемой командой:</em></p>
      
      <p><em><code>git config --global alias.visual'!gitk'</code></em></p>
      
      <p><strong><code>core.editor</code></strong> <em><code>editor</code></em></p>
      
      <p><em>добавить текстовый редактор</em></p>
      
      <p><strong><code>core.pager</code></strong> <em><code>pager</code></em></p>
      
      <p><em>установить пэйджер. Можно отключить использование пэйджера, передав пустую строку (<code>''</code>) в качестве значения</em></p>
      
      <p><strong><code>core.quotepath false</code></strong></p>
      
      <p><em>запретить вывод имен файлов в формате Unicode в виде числовых кодов при выполнении <code>git status</code></em></p>
      
      <p><strong><code>merge.tool</code></strong> <em><code>merge_tool</code></em></p>
      
      <p><em>добавить инструмент сравнения файлов</em></p>
      
      <p><strong><code>commit.template</code></strong> <em><code>template</code></em></p>
      
      <p><em>установить шаблон для записи передачи</em></p>
      
      <p><strong><code>core.excludesfile</code></strong> <em><code>path</code></em></p>
      
      <p><em>установить внешний файл с исключениями</em></p>
      
      <p><strong><code>help.autocorrect 1</code></strong></p>
      
      <p><em>установить автоматическое исправление опечаток</em></p>
      
      <p><strong><code>color.ui</code></strong> <em><code>{true | false | always}</code></em></p>
      
      <p><em>настроить цветной вывод. При установке опции always, цветной вывод будет присутствовать даже при перенаправлении данных в файл или другой команде</em></p>
      
      <h1 id="Создание_нового_репозитория">Создание нового репозитория</h1>
      
      <p><strong><code>git init</code></strong></p>
      
      <p><em>ининциализировать репозиторий</em></p>
      
      <p><strong><code>git status</code></strong></p>
      
      <p><em>вывести текущий статус</em></p>
      
      <p><strong><code>git checkout --</code></strong> <em><code>filename</code></em></p>
      
      <p><em>откатить сделанные в файле правки</em></p>
      
      <h1 id="Атрибуты">Атрибуты</h1>
      
      <h2 id="Файлы_атрибутов">Файлы атрибутов</h2>
      
      <pre><code>.gitattributes&#x000A;.git/info/attributes&#x000A;&#x000A;&lt;имя_файла&gt; export-ignore - игнорировать указанный файл при экспорте с помощью git archive.&#x000A;</code></pre>
      
      <h1 id="Закрепленные_сценарии">Закрепленные сценарии</h1>
      
      <p>Файлы с закрепленными сценариями содержаться в директории .git/hooks. Файл должен иметь название, соответствующее действию, которое должен совершать сценарий.</p>
      
      <h2 id="Клиентские_закрепленные_действия">Клиентские закрепленные действия</h2>
      
      <h2 id="Действия_связанные_с_передачей">Действия, связанные с передачей</h2>
      
      <pre><code>pre-commit - запускается сразу же после команды git commit и перед запуском текстового редактора. Если данный сценарий возвращает 0 (exit 0), то после него будет запущен текстовый редактор, если 1 (exit 1), то передача будет отменена.&#x000A;&#x000A;prepare-commit-msg - запускается переда запуском текстового редактора, но сразу же после создания текстового сообщения по умолчанию. Позволяет изменять текстовое сообщение по умолчанию. Имеет три аргумента:&#x000A;&#x000A;$*[0] - файл с текстовым сообщение по умолчанию;&#x000A;$*[1] - тип передачи (commit | template | squash);&#x000A;$*[2] - хэш передачи.&#x000A;&#x000A;commit-msg - запускается после закрытия текстового редактора и перед осуществлением передачи. Может быть использовано для проверки записи передачи на соответствие некоторым критериям. Имеет один аргумент:&#x000A;&#x000A;$*[0] - файл с текстовым сообщением.&#x000A;&#x000A;post-commit - запускается после успешного осуществления передачи.&#x000A;</code></pre>
      
      <h2 id="Действия_связанные_с_добавление_патчей">Действия, связанные с добавление патчей</h2>
      
      <pre><code>applypatch-msg - запускается перед добавлением патча командой git am. Позволяет проверить запись передачи на соответствие некоторым критериям. Если скрипт возвратит 1 (exit 1), то патч добавлен не будет, если 0 (exit 0), то патч будет добавлен. Имеет один аргумент:&#x000A;&#x000A;$*[0] - временный файл, содержащий запись передачи.&#x000A;&#x000A;pre-applypatch - запускается перед добавлением патча командой git am. Позволяет проверить некоторые изменения в файлах проекта. Если скрипт возвратит 1 (exit 1), то изменения в файлах будут выставлены, если 0 (exit 0), то патч будет добавлен. Не имеет аргументов.&#x000A;&#x000A;post-applypatch - запускается по завершению добавления патча командой git am. Не позволяет проводить какие-либо проверки и отменять обновление проекта. Не имеет аргументов.&#x000A;</code></pre>
      
      <h2 id="Действия_связанные_с_перебазированием_слиянием_и_выпиской">Действия, связанные с перебазированием, слиянием и выпиской</h2>
      
      <pre><code>pre-rebase - запускается перед перебазированием. Позволяет проверить некоторые условия перед этой операцией. Если сценарий возвратит 1 (exit 1), то перебазирование не будет осуществлено, если 0 (exit 0), то будет. Может иметь два либо один агрумент:&#x000A;&#x000A; передано два аргумента&#x000A;------------------------&#x000A;&#x000A;$*[0] - базовая ветвь;&#x000A;$*[1] - целевая ветвь.&#x000A;&#x000A; передан один аргумент&#x000A;-----------------------&#x000A;&#x000A;$*[0] - целевая ветвь;&#x000A;$*[1] - nil.&#x000A;&#x000A;post-merge - запускается после успешного слияния. Имеет один аргумент:&#x000A;&#x000A;$*[0] - флаг, указывающий на тип слияния (0 - обычное, 1 - слияние через сжатие).&#x000A;&#x000A;post-checkout - запускается после выписки. Имеет три аргумента:&#x000A;&#x000A;$*[0] - полный хэш последней передачи в текущей ветви;&#x000A;$*[1] - полный хэш последней передачи в выписанной ветви;&#x000A;$*[2] - флаг, указывающий на тип выписки (0 - выписка файла, 1 - выписка ветви).&#x000A;</code></pre>
      
      <h2 id="Серверные_закрепленные_действия">Серверные закрепленные действия</h2>
      
      <p>Серверные закрепленные сценарии должны содержаться в директории hooks/ в удаленном репозитории.</p>
      
      <pre><code>pre-receive - запускается после получения обновлений от клиента, перед добавлением этих обновлений в удаленный репозиторий. Будет выполнено один раз вне зависимости от того, сколько ветвей предполагается обновить. Позволяет отклонять обновления удаленного репозитория. Если сценарий возвращает 1 (exit 1), то обновления не произойдет, если 0 (exit 0), то обновление пройдет успешно. Не имеет аргументов.&#x000A;&#x000A;update - запускается после получения обновлений от клиента, перед добавлением этих обновлений в удаленный репозиторий. Будет выполнено столько раз, сколько ветвей предполагается обновить. Позволяет отклонять обновления определенных ветвей удаленного репозитория. Если сценарий возвращает 1 (exit 1), то обновления не произойдет, если 0 (exit 0), то обновление пройдет успешно. Имеет три аргумента:&#x000A;&#x000A;$*[0] - полное имя ветви предполагаемой для обновления;&#x000A;$*[1] - хэш текущей передачи для данной ветви;&#x000A;$*[2] - хэш последней добавленной передачи для данной ветви.&#x000A;&#x000A;post-receive - запускается после добавления обновлений, полученных от клиента. Будет выполнено один раз вне зависимости от того сколько ветвей было обновлено. Не имеет аргументов.&#x000A;</code></pre>
      
      <h1 id="Выставление">Выставление</h1>
      
      <pre><code>git add &lt;имя_файла&gt; - выставить файл для передачи.&#x000A;&#x000A;  git add -i - войти в интерактивный режим.&#x000A;&#x000A;  git add -p - войти в режим правки.&#x000A;&#x000A;  git add -e - открыть текстовый редактор для редактирования выставленных изменений.&#x000A;&#x000A;git reset HEAD &lt;имя_файла&gt; - снять выставленный файл.&#x000A;&#x000A;git rm &lt;имя_файла&gt; - выставить файл для удаления.&#x000A;&#x000A;  git rm &lt;имя_файла&gt; --cached - удалить файл из репозитория, но не из проекта.&#x000A;&#x000A;git mv &lt;имя_файла&gt; &lt;новое_имя_файла&gt; - выставить файл для переименования.&#x000A;</code></pre>
      
      <h1 id="Откладывание_изменений">Откладывание изменений</h1>
      
      <pre><code>git stash - отложить сделанные изменения.&#x000A;&#x000A;  git stash list - вывести список отложенных изменений.&#x000A;&#x000A;  git stash show stash@{&lt;n&gt;} - посмотреть краткие сведения об указанном отложенном изменении.&#x000A;&#x000A;    git stash show -p stash@{&lt;n&gt;} - посмотреть подробные сведения об указанном отложенном изменении.&#x000A;&#x000A;  git stash apply stash@{&lt;n&gt;} - добавить n-ное отложенное изменение.&#x000A;&#x000A;  git stash drop stash@{&lt;n&gt;} - удалить n-ное отложенное изменение из списка.&#x000A;&#x000A;  git stash branch &lt;имя&gt; stash@{&lt;n&gt;} - создать ветвь из отложенного изменения и удалить последнее.&#x000A;</code></pre>
      
      <h1 id="Передача">Передача</h1>
      
      <pre><code>git commit - осуществить передачу всех выставленных файлов.&#x000A;&#x000A;  git commit -m '&lt;описание&gt;' - осуществить передачу всех выставленных файлов с добавленным описанием.&#x000A;&#x000A;  git commit &lt;имя_файла&gt; - осуществить передачу указанного файла вне зависимости от того, является ли он выставленным или нет.&#x000A;&#x000A;  git commit -а - передать все измененные и добавленные файлы как выставленные, так и невыставленные.&#x000A;</code></pre>
      
      <h1 id="Исправление_и_откат_сделанных_передач">Исправление и откат сделанных передач</h1>
      
      <pre><code>git commit --amend -m &lt;новая_запись&gt; - изменить журнальную запись для последней передачи, а так же добавить выставленные изменения в последнюю передачу, если таковые имеются.&#x000A;&#x000A;git commit --amend -C HEAD - добавить выставленные изменения в уже совершенную передачу.&#x000A;&#x000A;git commit --amend -a -C HEAD - добавить невыставленные изменения в уже совершенную передачу.&#x000A;&#x000A;git revert &lt;хэш&gt; - осуществить передачу, отменяющую изменения в указанной передачи. Если необходимо осуществить отменяющую передачу не для последней передачи, то нужно последовательно выполнить данный тип передачи несколько раз, начиная с последней передачи.&#x000A;  git revert -n &lt;хэш&gt; - выставить отмененные изменения. При пакетной отмене, можно использовать идиому: git revert -n HEAD; git revert -n HEAD^; git revert -n HEAD^^ и т. д.&#x000A;  git revert --no-edit &lt;хэш&gt; - не запускать редактор при выполнении отменяющей передачи. В этом случае в качестве журнального сообщения будет присутствовать стандартная запись.&#x000A;&#x000A;git reset &lt;хэш&gt; - переместится в истории изменений до указанной передачи, удалив все последующие, не выставляя все осуществленные изменения.&#x000A;&#x000A;  git reset --soft &lt;хэш&gt; - переместиться в истории изменений до указанной передачи, удалив все последующие, выставив все осуществленные изменения.&#x000A;&#x000A;  git reset --hard &lt;хэш&gt; - переместиться в истории изменений до указанной передачи, удалив все последующие.&#x000A;&#x000A;git filter-branch --tree-filter 'rm -f &lt;файл&gt;' &lt;ветвь&gt; - удалить указанный файл во всех передачах ветви. Будет создана резервная копия. Удалить её можно следующей командой.&#x000A;&#x000A;  git update-ref -d &lt;ветвь&gt; &lt;хэш&gt;&#x000A;&#x000A;Если затем попытаться повторно удалить некий файл уже из другой ветви, то команда возвратит ошибку, сообщающую о невозможности перезаписать резервную копию. Для того, чтобы форсировать перезапись нужно добавить опцию -f к команде.&#x000A;&#x000A;  git filter-branch -f --tree-filter 'rm -f &lt;файл&gt;' &lt;ветвь&gt;&#x000A;&#x000A;  git filtrer-branch --tree-filter 'rm -f &lt;файл&gt;' -- --all - удалить указанный файл во всех передачах всех ветвей.&#x000A;</code></pre>
      
      <h1 id="Журналирование">Журналирование</h1>
      
      <pre><code>git log - просмотр всех сделанных передач.&#x000A;&#x000A;  git log --format='&lt;строка_форматирования&gt;' - вывести журнал передач и форматировать вывод.&#x000A;  git log -&lt;число&gt; - просмотр определенного количества последних передач.&#x000A;  git log &lt;хэш&gt; - просмотр журнала до указанной передачи.&#x000A;  git log [&lt;хэш&gt; | &lt;метка&gt;]..[&lt;хэш&gt; | &lt;метка&gt; | HEAD | ''] - просмотр журнала в указанном интервале без включения в него первого хэша.&#x000A;&#x000A;    git log --oneline --left-right &lt;ветвь_1&gt;...&lt;ветвь_2&gt; - просмотреть изменения в указанных ветвях имеющих общего предка и вывести указатели на ветвь в соответствующих передачах.&#x000A;&#x000A;  git log --since='[&lt;время&gt; | &lt;год-число.месяц&gt;]' - просмотр журнала за указанное время, либо начиная с указанной даты.&#x000A;  git log --before='[&lt;время&gt; | &lt;год-число.месяц&gt;]' - просмотр журнала до указанного времени или даты.&#x000A;&#x000A;  git log -p - просмотр всех сделанных передач вместе со сделанными изменениями в файлах.&#x000A;&#x000A;  git log --graph - просмотр журнала передач с графическим отображением ветвей.&#x000A;&#x000A;  git log -- &lt;путь&gt; - просмотр изменений указанного файла.&#x000A;&#x000A;  git log &lt;целевая_ветвь&gt; {--not &lt;базовая_ветвь&gt; | ^&lt;базовая_ветвь&gt;} - просмотр всех передач в целевой ветви, исключая передачи в базовой.&#x000A;&#x000A;  git log --graph --oneline --decoration=short --all - просмотреть все передачи во всех ветвях в графическом режиме, отображая каждую передачу на одной строке, показав имена всех ветвей.&#x000A;&#x000A;git rev-parse &lt;метка&gt; - просмотр полного хэша для отмеченной передачи.&#x000A;&#x000A;git show &lt;метка&gt; - просмотр данных об указанной метки вместе с данными о передачи, которая была отмечена.&#x000A;&#x000A;&#x000A;Cписок символов форматирования:&#x000A;  %h - укороченный хэш;&#x000A;  %s - заголовок передачи;&#x000A;  %b - тело передачи;&#x000A;  %n - новая строка.&#x000A;&#x000A;Список спецсимволов:&#x000A;  ^        - текущая передача минус один;&#x000A;  ^&lt;число&gt; - следующий предок текущей передачи (если предков несколько);&#x000A;  ~&lt;число&gt; - текущая передача минус указанное чилсло.&#x000A;</code></pre>
      
      <h1 id="Просмотр_изменений">Просмотр изменений</h1>
      
      <pre><code>git diff &lt;xэш&gt; - просмотреть изменения между указанной передачей и текущей передачей.&#x000A;  git diff &lt;хэш&gt; &lt;файл&gt; - просмотреть изменения между указанной передачей и текущей передачей в указанном файле.&#x000A;&#x000A;git diff &lt;метка&gt;..&lt;метка&gt; - просмотреть изменения в указанном интервале.&#x000A;&#x000A;git diff &lt;базовая_ветвь&gt;...&lt;целевая_ветвь&gt; - просмотр изменений между целевой ветвью и общим предком базовой и целевой ветвей.&#x000A;&#x000A;git diff --stat - вывести сводный отчет по изменениям.&#x000A;&#x000A;git diff - просмотр изменений между невыставленным файлом и выставленным файлом или репозиторием, если нет выставленного файла.&#x000A;&#x000A;git diff --staged - просмотр изменений между выставленным файлом и файлом в репозитории.&#x000A;&#x000A;git diff HEAD - просмотр изменений между файлом в репозитории и выставленным файлом вместе с невыставленным файлом.&#x000A;&#x000A;git diff --check - проверить файл на наличие завершающих пробелов.&#x000A;&#x000A;git diff -U&lt;количество_строк&gt; - установить количество строк, которые будут отображаться в выводе до и после измененной строки. Например:&#x000A;&#x000A;  git diff -U1&#x000A;&#x000A;отбразит одну строку до и одну после измененной строки,&#x000A;&#x000A;  git diff -U10&#x000A;&#x000A;отобразит десять строк до и десять после измененной строки, а&#x000A;&#x000A;  git diff -U0&#x000A;&#x000A;отобразит только измененную строку.&#x000A;&#x000A;git difftool - просмотреть изменения в специализированной программе.&#x000A;  git difftool -y - просмотреть изменения в специализированной программе и не показывать предупреждение.&#x000A;&#x000A;git blame &lt;файл&gt; - построчно просмотреть изменения, сделанные в указанном файле с включением в вывод хэша передачи, автора, времени изменения и пр. информации.&#x000A;  git blame -L &lt;начальная_строка&gt;,[&lt;конечная_строка&gt;, | -&lt;отклонение&gt; | +&lt;отклонение&gt;] &lt;файл&gt; - просмотр изменений в указанном интервале строк.&#x000A;  git blame &lt;хэш&gt;[^ | ~&lt;отклонение&gt;] - просмотр изменений до указанной передачи.&#x000A;  git blame &lt;хэш&gt;..&lt;хэш&gt; - просмотр изменений в указанном интервале передач.&#x000A;</code></pre>
      
      <h1 id="Ветвление">Ветвление</h1>
      
      <pre><code>git branch - показать все текущие ветви и отметить рабочую.&#x000A;  git branch -v - показать все ветви, отметить текущую и вывести последнюю передачу для каждой ветви.&#x000A;  git branch -r - показать все ветви в удаленном репозитории.&#x000A;  git branch &lt;имя_ветви&gt; &lt;имя_родительской_ветви&gt; - создать ветвь.&#x000A;  git branch &lt;имя_новой_ветви&gt; &lt;имя_метки&gt; - восстановить ветвь с указанной метки.&#x000A;  git branch -d &lt;имя_ветви&gt; - удалить ветвь. Ветвь должна быть слита.&#x000A;    git branch -rd &lt;имя_ветви&gt; - удалить удаленную ветвь.&#x000A;  git branch -D &lt;имя_ветви&gt; - удалить ветвь вне зависимости от того, слита она или нет.&#x000A;  git branch -m &lt;прежнее_имя&gt; &lt;новое_имя&gt; - переименовать ветвь.&#x000A;&#x000A;git checkout &lt;имя_ветви&gt; - выписать указанную ветвь.&#x000A;  git checkout -b &lt;имя_новой_ветви&gt; &lt;имя_родительской_ветви&gt; - создать новую ветвь и сразу же переключиться на неё.&#x000A;</code></pre>
      
      <h1 id="Слияние">Слияние</h1>
      
      <pre><code>git merge &lt;имя_ветви&gt; - осуществить прямое слияние текущей ветви с указанной.&#x000A;  git merge --no-commit &lt;имя_ветви&gt; - выствить слияние.&#x000A;  git merge --squash &lt;имя_ветви&gt; - выставить объединенные передачи указанной ветви для текущей.&#x000A;  git cherry-pick &lt;укороченный_дайджест&gt; - осуществить передачу, помеченную дайджестом, для текущей ветви.&#x000A;  git cherry-pick {-n | --no-commit} &lt;укороченный_дайджест&gt; - выставить передачу, помеченную дайджестом, для текущей ветви.&#x000A;&#x000A;git mergetool &lt;программа_сравнения&gt; - использовать программу сравнения для разрешения конфликтов слияния.&#x000A;&#x000A;git merge-base &lt;ветвь_1&gt; &lt;ветвь_2&gt; - найти общего предка между двумя ветвями.&#x000A;</code></pre>
      
      <h1 id="Перебазирование">Перебазирование</h1>
      
      <pre><code>git rebase &lt;базовая_ветвь&gt; &lt;целевая_ветвь&gt; - перебазировать целевую ветвь в конец базовой.&#x000A;  git rebase &lt;ветвь&gt; - перебазировать текущую ветвь в конец указанной.&#x000A;&#x000A;git rebase --onto &lt;базовая_ветвь&gt; &lt;ветвь_посредник&gt; &lt;целевая_ветвь&gt; - перебазировать целевую ветвь в конец базовой, исключая предка в ветви посреднике.&#x000A;  git reabase --onto &lt;базовая_ветвь&gt; &lt;ветвь_посредник&gt; - перебазировать текущую ветвь в конец базовой, исключая предка в ветви посреднике. &#x000A;&#x000A;git rebase -i &lt;хэш&gt; - войти в интерактивный режим для изменения порядка передач.&#x000A;</code></pre>
      
      <h1 id="Метки">Метки</h1>
      
      <pre><code>git tag &lt;метка&gt; &lt;имя_ветви&gt; - добавить легковесную метку для указанной ветви.&#x000A;  git tag &lt;метка&gt; &lt;укороченный_дайджест_передачи&gt; - установить метку для одной из предыдущих передач.&#x000A;  git tag -a &lt;метка&gt; -m &lt;описание&gt; - добавить аннотированную метку для текущей ветви.&#x000A;  git tag - возвратить список меток.&#x000A;  git tag -d &lt;метка&gt; - удалить указанную метку.&#x000A;</code></pre>
      
      <h1 id="Работа_с_удаленными_репозиториями">Работа с удаленными репозиториями</h1>
      
      <pre><code>git clone &lt;URL&gt; - клонировать репозиторий в локальный каталог.&#x000A;&#x000A;git remote add &lt;имя&gt; &lt;URL&gt; - добавить удаленный репозиторий.&#x000A;git remote -v - просмотр всех удаленных репозиториев и их URL.&#x000A;git remote rm &lt;имя&gt; - удалить указанный удаленный репозиторий.&#x000A;&#x000A;git fetch {&lt;url&gt; | &lt;локальное_имя&gt;} - скачать объекты из указанного удаленного репозитория и не сливать их с имеющимися в локальном репозитории.&#x000A;&#x000A;git pull {&lt;url&gt; | &lt;локальное_имя&gt;} - скачать объекты из указанного удаленного репозитория и слить их с имеющимися в локальном репозитории.&#x000A;&#x000A;git push [&lt;имя_удаленного_репозитория&gt;] - обновить удаленный репозиторий.&#x000A;  git push --dry-run - имитировать обновление репозитория.&#x000A;  git push &lt;репозиторий&gt; &lt;ветвь&gt; - обновить удаленный репозиторий, добавив в него только указанную ветвь.&#x000A;  git push &lt;репозиторий&gt; &lt;ветвь&gt;:&lt;имя_в_удаленном_репозитории&gt; - обновить удаленный репозиторий, добавив в него указанную ветвь, но сохранив её под другим именем.&#x000A;  git push &lt;удаленный_репозиторий&gt; :&lt;удаляемая_ветвь&gt; - удалить указанную ветвь из удаленного репозитория.&#x000A;  git push -f - осуществить настойчивое обновление.&#x000A;  git push --tags - добавить в репозиторий все имеющиеся метки.&#x000A;&#x000A;  git request-pull &lt;начальная_ссылка&gt; &lt;url_репозитория&gt; [&lt;конечная_ссылка&gt;] - вывысти на экран сводную статистику по передачам, ожидающим вытягивания со стороны менеджера.&#x000A;</code></pre>
      
      <h1 id="Субмодули">Субмодули</h1>
      
      <pre><code>git submodule - просмотреть субмодули.&#x000A;  git submodule add &lt;репозиторий&gt; &lt;имя&gt; - создать директорую с указанным именем и добавить в неё указанный репозиторий.&#x000A;  git submodule init &lt;имя&gt; - инициализировать (добавить запись о субмодуле в .git/config) указанный субмодуль.&#x000A;  git submodule update &lt;имя&gt; - обновить субмодуль.&#x000A;</code></pre>
      
      <h1 id="Архивирование">Архивирование</h1>
      
      <pre><code>git archive --format=&lt;tar | zip&gt; --prefix=&lt;имя&gt;/ &lt;ветвь&gt; - поместить все файлы проекта в директорию с указанным именем и создать архив указанного формата.&#x000A;&#x000A;  git archive --format=tar --prefix=&lt;имя&gt;/ &lt;ветвь&gt; | gzip &gt; &lt;имя&gt;.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата tar и сжать этот архив, сохраняя в файле .tar.gz.&#x000A;&#x000A;  git archive --prefix=&lt;имя&gt;/ &lt;ветвь&gt; | gzip &gt; `git describe --tags master`.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата по умолчанию (tar) и сжать этот архив, сохраняя в файле с именем являющимся выводом команды git-describe, добавляя расширение .tar.gz.&#x000A;&#x000A;    git describe --tags &lt;ветвь&gt; - показать самую последнюю созданную метку, учитывая неаннотированные метки. Вывод команды имеет следующий формат: &lt;имя_тэга&gt;-&lt;количество_сделанных_передач&gt;-g&lt;хэш_последней_передачи&gt;. "g" в выводе означает, что используется VCS git.&#x000A;</code></pre>
      
      <h1 id="Патчи">Патчи</h1>
      
      <pre><code>git format-patch [&lt;начальная_передача&gt; | &lt;начальная_передача&gt;..&lt;конечная_передача&gt;] - подготовить файлы с патчами для отправки по электронной почте. Использовать либо все передачи начиная с начальной до текущей, либо все передачи в указанном интервале.&#x000A;&#x000A;  git format-patch -o &lt;директория_вывода&gt; - подготовить файлы патчей и сохранить их в указанной директории.&#x000A;&#x000A;  git format-patch --stdout - подготовить файлы патчей и вывести их содержимое в консоль.&#x000A;&#x000A;git apply &lt;файл_патча&gt; - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданные с помощью следующих команд.&#x000A;&#x000A;  $ git diff &lt;старт-метка&gt;..&lt;финиш-метка&gt; &gt; &lt;имя&gt;.patch&#x000A;  $ git log -p &lt;старт-метка&gt;..&lt;финиш-метка&gt; &gt; &lt;имя&gt;.patch&#x000A;&#x000A;git am {&lt;mbox-файл&gt; | &lt;файл_патча&gt;} - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданный с помощью следующей команды.&#x000A;&#x000A;  $ git format patch &lt;старт-метка&gt;..&lt;финиш_метка&gt; -о &lt;директория&gt;&#x000A;&#x000A;  git am -i {&lt;mbox-файл&gt; | &lt;файл-патча&gt;} - добавить изменеия в файлы проекта в интерактивном режиме.&#x000A;&#x000A;  git am -3 {&lt;mbox-файл&gt; | &lt;файл-патча&gt;} - добавить изменения в файлы проекта. При возникновении конфлика добавить конфликтные маркеры в файлы с конфликтами.&#x000A;</code></pre>
      
      <h1 id="Отпавка_патчей_по_электронной_почте">Отпавка патчей по электронной почте</h1>
      
      <p>Для отправки почты необходимо установить пакет sendmail.</p>
      
      <pre><code>git send-email --from=&lt;адрес_отправителя&gt; --to=&lt;адрес_получателя&gt; {&lt;список_файлов&gt; | &lt;директория&gt;} - отправить на указанный адрес либо перечисленные файлы патчей, либо все файлы в указанной директории.&#x000A;&#x000A;   Настройка git send-email&#x000A;  --------------------------&#x000A;    # ~/.gitconfig&#x000A;    [sendemail]&#x000A;      smtpserver = &lt;адрес_smtp-сервера&gt; (smtp.gmail.com)&#x000A;      smtpserverport = &lt;порт_smpt-сервера&gt; ({587 | 465})&#x000A;      smtpencryption = &lt;криптографический_протокол&gt; ({tls | ssl})&#x000A;      smtpuser = &lt;логин&gt; (login@gmail.com)&#x000A;      smtppass = &lt;пароль&gt; (password)&#x000A;      from = &lt;адрес_отправителя&gt;&#x000A;      to = &lt;адрес_получателя&gt;&#x000A;      confirm = {always | never}&#x000A;&#x000A;git format-patch --stdout {&lt;начальная_передача&gt; | &lt;интервал&gt;} | git imap-send - загрузить файлы патчей в директорию с черновиками на почтовом сервере.&#x000A;&#x000A;   Настройка git imap-send&#x000A;  -------------------------&#x000A;    # ~/.gitconfig&#x000A;    [imap]&#x000A;      folder = &lt;директория_с_черновиками&gt; ([Gmail]/Черновики)&#x000A;      host = &lt;адрес_почтового_сервера&gt; ({imaps:// | imap://}imap.gmail.com)&#x000A;      port = &lt;порт_почтового_сервера&gt; ({993 | 143})&#x000A;      user = &lt;логин&gt; (login@gmail.com)&#x000A;      pass = &lt;пароль&gt; (password)&#x000A;      sslverify = &lt;логическое_значение&gt; ({false | true})&#x000A;</code></pre>
      
      <h1 id="Восстановление_и_очистка">Восстановление и очистка</h1>
      
      <pre><code>git gc - удалить ненужные файлы и произвести оптимизацию локального репозитория.&#x000A;&#x000A;git reflog - отобразить журнал изменений.&#x000A;</code></pre>
      
      <h1 id="Пошаговый_поиск_проблемных_передач">Пошаговый поиск проблемных передач</h1>
      
      <pre><code>git bisect start &lt;проблемная_передача&gt; &lt;беспроблемная_передача&gt; - начать пошаговый поиск в указанном интервале.&#x000A;&#x000A;  git bisect bad  - отметить передачу как проблемную.&#x000A;  git bisect good - отметить передачу как беспроблемную.&#x000A;&#x000A;  git bisect reset - закончить пошаговый поиск.&#x000A;&#x000A;    git bisect reset &lt;метка&gt; - закончить пошаговый поиск и установить указатель HEAD на отмеченную передачу.&#x000A;</code></pre>
      
      <h1 id="Gitosis">Gitosis</h1>
      
      <h2 id="Порядок_установки_менеджера_репозиториев_Gitosis">Порядок установки менеджера репозиториев Gitosis</h2>
      
      <p>\1. На удаленной машине создать пользователя git.</p>
      
      <pre><code># adduser \&#x000A;&gt; --system \&#x000A;&gt; --group \&#x000A;&gt; --disabled-password \&#x000A;&gt; --shell /bin/sh \&#x000A;&gt; --home /home/git \&#x000A;&gt; git&#x000A;</code></pre>
      
      <p>\2. На локальной машине создать публичный ключ для использования вместе с SSH.</p>
      
      <pre><code>$ ssh-keygen -t rsa&#x000A;</code></pre>
      
      <p>Если не указывать пароль для ключа, то при подключении к SSH-серверу система не будет требовать аутентификации. Обе части ключа (публичная и частная) будут размещены в директории ~/.ssh</p>
      
      <p>\3. Скопировать публичную часть ключа (&lt;имя_ключа&gt;.pub) на сервер в директорию /путь/к/публичному/ключу.</p>
      
      <p>\4. Инициализировать Gitosis на удаленной машине.</p>
      
      <pre><code># su git -c 'gitosis-init &lt; /путь/к/публичному/ключу'&#x000A;</code></pre>
      
      <p>\4.1 Добавить алиас для IP-адреса удаленной машины в файл /etc/hosts локальной машины.</p>
      
      <pre><code>$ vim /etc/hosts&#x000A;$ cat /etc/hosts&#x000A;...&#x000A;192.168.1.14 pavel-server&#x000A;...&#x000A;</code></pre>
      
      <h2 id="Настройка_Gitosis">Настройка Gitosis</h2>
      
      <p>1) Склонировать конфигурацоный репозиторий Gitosis на локальную машину. Если для пользователя был установлен пароль, то он будет запрошен.</p>
      
      <pre><code>$ git clone git@pavel-server:gitosis-admin.git&#x000A;</code></pre>
      
      <p>или</p>
      
      <pre><code>$ git clone ssh://git@pavel-server/gitosis-admin.git&#x000A;</code></pre>
      
      <p>2) Перейти в директорию gitosis-admin.git и открыть файл gitosis.conf.</p>
      
      <pre><code>$ cd gitosis-admin&#x000A;$ vim gitosis.conf&#x000A;</code></pre>
      
      <p>3.1) Для настройки доступа к конфигурации Gitosis добавить нового пользователя в графу ‘members’ секции ‘[group gitosis-admin]’. Для добавления нескольких пользователей, необходимо перечислить их в данной графе, разделяя пробелами. Не стоит добавлять лишние пробелы в конфигурационный файл во избежании возникновения ошибки интерпретатора языка Perl при отправке изменений на сервер*.</p>
      
      <pre><code>$ cat gitosis.conf&#x000A;[group gitosis-admin]&#x000A;writable = gitosis-admin&#x000A;members = &lt;пользователь_1&gt; &lt;пользователь_2&gt; ...&#x000A;</code></pre>
      
      <p>*Hо не.</p>
      
      <pre><code>[group gitosis-admin]&#x000A;  writable = gitosis-admin&#x000A;  members  = &lt;пользователь_1&gt; &lt;пользователь_2&gt; ...&#x000A;</code></pre>
      
      <p>3.2) Для добавления нового частного репозитория добавить новую секцию.</p>
      
      <pre><code>[group &lt;группа_чтение-запись&gt;]&#x000A;writable = &lt;репозиторий_а&gt;&#x000A;members = &lt;пользователь_1&gt; &lt;пользователь_2&gt; ...&#x000A;</code></pre>
      
      <p>Все перечисленные пользователи будут иметь право доступа и записи в созданный репозиторий.</p>
      
      <pre><code>[group &lt;группа_только_чтение&gt;]&#x000A;readonly = &lt;репозиторий_а&gt;&#x000A;members = &lt;пользователь_3&gt; &lt;пользователь_4&gt; ...&#x000A;</code></pre>
      
      <p>Здесь, все перечисленные пользователи смогут только клонировать указанный репозиторий. Они не будут иметь право записи.</p>
      
      <pre><code>[repo &lt;репозиторий_а&gt;]&#x000A;daemon = yes&#x000A;</code></pre>
      
      <p>Добавив данную секцию можно открыть публичный доступ к указанному репозиторию. Для того, чтобы пользователи могли скачивать этот репозиторий необходимо запустить git-daemon на удаленной машине.</p>
      
      <pre><code># su git -c "git daemon --base-path=&lt;git-home&gt;/repositories"&#x000A;</code></pre>
      
      <p>Таким образом будет открыт общий доступ к данному репозиторию с правом чтения, но не записи. Непривелигированные пользователи будут иметь возможность скачивать репозиторий по протоколу git.</p>
      
      <pre><code>$ git clone git://&lt;хост&gt;/&lt;путь&gt;.git&#x000A;</code></pre>
      
      <p>Например:</p>
      
      <pre><code>$ git clone git://pavel-server/project.git&#x000A;</code></pre>
      
      <h1 id="Примеры">Примеры</h1>
      
      <h2 id="Создание_локального_репозитория">Создание локального репозитория</h2>
      
      <pre><code>1. $ mkdir project; cd project; git init&#x000A;2. $ touch README; git add .; git commit -m 'init'&#x000A;3. $ mkdir ../project.git; git init --bare ../project.git&#x000A;4. $ git remote add origin file://&lt;путь_к_project.git&gt;&#x000A;5. $ git push origin master&#x000A;</code></pre>
      
      <h2 id="Добавление субмодуля">Добавление субмодуля</h2>
      
      <pre><code>1. $ git submodule add &lt;путь&gt; &lt;имя&gt;&#x000A;2. $ git submodule init &lt;имя&gt;&#x000A;</code></pre>
      
      <h2 id="Добавления_субмодуля_в_составе_склонированного_репозитория">Добавления субмодуля в составе склонированного репозитория</h2>
      
      <pre><code>1. $ git submodule init &lt;имя&gt;&#x000A;2. $ git submodule update &lt;имя&gt;&#x000A;</code></pre>
      
      <h2 id="Исправление_журнальной_записи_передачи">Исправление журнальной записи передачи</h2>
      
      <pre><code>1. $ git rebase -i &lt;хэш_родительской_передачи_для_проблемной&gt;&#x000A;2. Откроется текстовый редактор с перечнем передач.&#x000A;3. Сменить метки pick на edit во всех проблемных передачах.&#x000A;4. Сохранить изменения и закрыть редактор.&#x000A;5. $ git commit --amend&#x000A;6. Откроется редактор с текстом журнальной записи.&#x000A;7. Исправить запись, сохранить изменения, закрыть редактор.&#x000A;8. $ git rebase --continue&#x000A;9. Повторить шаги 5-8 для всех проблемных передач.&#x000A;</code></pre>
      
      <h2 id="Разбивка_одной_передачи_на_несколько">Разбивка одной передачи на несколько</h2>
      
      <pre><code>1. $ git rebase -i &lt;метка&gt;&#x000A;2. Откроется текстовый редактор с перечнем передач.&#x000A;3. Сменить метку pick на edit в проблемной передаче.&#x000A;4. $ git reset HEAD^&#x000A;5. Измененный файл окажется в невыставленной области.&#x000A;6. $ git add -e&#x000A;7. Отредактировать файл, добавляя необходимые изменения.&#x000A;8. $ git commit&#x000A;9. Повторить шаги 6-8 для всех изменений.&#x000A;10. $ git rebase --continue&#x000A;</code></pre>
    </main>
    <footer></footer>
  </body>
</html>
