---
title: Git
---

#Содержание
{: id="Содержание"}

[Конфигурация](#Конфигурация)

[Создание нового репозитория](#Создание_нового_репозитория)

[Атрибуты](#Атрибуты)

[Закрепленные сценарии](#Закрепленные_сценарии)

[Выставление](#Выставление)

[Откладывание изменений](#Откладывание_изменений)

[Передача](#Передача)

[Исправление и откат сделанных передач](#Исправление_и_откат_сделанных_передач)

[Журналирование](#Журналирование)

[Просмотр изменений](#Просмотр_изменений)

[Ветвление](#Ветвление)

[Слияние](#Слияние)

[Перебазирование](#Перебазирование)

[Метки](#Метки)

[Работа с удаленными репозиториями](#Работа_с_удаленными_репозиториями)

[Субмодули](#Субмодули)

[Архивирование](#Архивирование)

[Патчи](#Патчи)

[Отправка патчей по электронной почте](#Отправка_патчей_по_электронной_почте)

[Восстановление и очистка](#Восстановление_и_очистка)

[Пошаговый поиск проблемных передач](#Пошаговый_поиск_проблемных_передач)

[Gitosis](#Gitosis)

[Примеры](#Примеры)

#Конфигурация
{: id="Конфигурация"}

##Команды конфигурации
{: id="Команды_конфигурации"}

**`git config --system`** _`option`_ _`value`_

_системная (/etc/gitconfig)_

**`git config --global`** _`option`_ _`value`_

_глобальная (~/.gitconfig)_

**`git config`** _`option`_ _`value`_

_локальная (.git/config)_

##Опции
{: id="Опции"}

**`alias.`**_`old_command`_ _`new_command`_

_добавить замену для стандартной команды_

_При замене глобальной команды следует поставить „!“ перед заменяемой командой:_

_`git config --global alias.visual'!gitk'`_

**`core.editor`** _`editor`_

_добавить текстовый редактор_

**`core.pager`** _`pager`_

_установить пэйджер. Можно отключить использование пэйджера, передав пустую строку (`''`) в качестве значения_

**`core.quotepath false`**

_запретить вывод имен файлов в формате Unicode в виде числовых кодов при выполнении `git status`_

**`merge.tool`** _`merge_tool`_

_добавить инструмент сравнения файлов_

**`commit.template`** _`template`_

_установить шаблон для записи передачи_

**`core.excludesfile`** _`path`_

_установить внешний файл с исключениями_

**`help.autocorrect 1`**

_установить автоматическое исправление опечаток_

**`color.ui`** _`{true | false | always}`_

_настроить цветной вывод. При установке опции always, цветной вывод будет присутствовать даже при перенаправлении данных в файл или другой команде_

#Создание нового репозитория
{: id="Создание_нового_репозитория"}

**`git init`**

_ининциализировать репозиторий_

**`git status`**

_вывести текущий статус_

**`git checkout --`** _`filename`_

_откатить сделанные в файле правки_

#Атрибуты
{: id="Атрибуты"}

##Файлы атрибутов
{: id="Файлы_атрибутов"}

    .gitattributes
    .git/info/attributes

    <имя_файла> export-ignore - игнорировать указанный файл при экспорте с помощью git archive.

#Закрепленные сценарии
{: id="Закрепленные_сценарии"}

[Клиентские закрепленные действия](#Клиентские_закрепленные_действия)

[Действия связанные с фиксацией правок](#Действия_связанные_с_фиксацией_правок)

[Действия связанные с добавление патчей](#Действия_связанные_с_добавление_патчей)

[Серверные закрепленные действия](#Серверные_закрепленные_действия)

Файлы с закрепленными сценариями содержатся в каталоге `.git/hooks`. Файл должен
иметь название, соответствующее действию, которое должен совершать сценарий.

##Клиентские закрепленные действия
{: id="Клиентские_закрепленные_действия"}

_пусто_

##Действия, связанные с фиксацией правок
{: id="Действия_связанные_с_фиксацией_правок"}

**`pre-commit`**

Запускается сразу же после команды `git commit` и перед запуском текстового
редактора. Если данный сценарий возвращает „0“ (`exit 0`), то после него будет
запущен текстовый редактор, если „1“ (`exit 1`), то фиксация правки будет
отменена.

**`prepare-commit-msg`**

Запускается перед запуском текстового редактора, но сразу же после создания
текстового сообщения по умолчанию. Позволяет изменять текстовое сообщение по
умолчанию. Имеет три аргумента:

`$*[0]` — файл с текстовым сообщением по умолчанию;

`$*[1]` — тип правки `{commit | template | squash}`;

`$*[2]` — хэш правки.

**`commit-msg`**

Выполняется после закрытия текстового редактора и перед фиксацией правки. Может
быть использован для проверки журнальной записи на соответствие некоторым
критериям. Имеет один аргумент:

`$*[0]` — файл с текстовым сообщением.

**`post-commit`**

Запускается после успешной фиксации правки.

##Действия, связанные с добавление патчей
{: id="Действия_связанные_с_добавление_патчей"}

**`applypatch-msg`**

Запускается перед добавлением патча командой `git am`. Если сценарий возвратит
„1“ (`exit 1`), то патч добавлен не будет, если „0“ (`exit 0`), то патч будет
добавлен. Имеет один аргумент:

`$*[0]` — временный файл, содержащий журнальную запись.

**`pre-applypatch`**

Запускается перед добавлением патча командой `git am`. Позволяет проверить
некоторые изменения в файлах проекта. Если сценарий возвратит „1“ (`exit 1`), то
изменения в файлах будут выставлены, если „0“ (exit 0), то патч будет добавлен.
Не имеет аргументов.

**`post-applypatch`**

Запускается по завершению добавления патча командой `git am`. Не позволяет
проводить какие-либо проверки и отменять обновление проекта. Не имеет
аргументов.

##Действия, связанные с перебазированием, слиянием и выпиской
{: id="Действия_связанные_с_перебазированием_слиянием_и_выпиской"}

**`pre-rebase`**

Запускается перед перебазированием. Позволяет проверить некоторые условия перед
этой операцией. Если сценарий возвратит „1“ (`exit 1`), то перебазирование не
будет осуществлено, если „0“ (`exit 0`), то будет. Может иметь два, либо один
аргумент:

`$*[0]` — базовая ветвь;

`$*[1]` — целевая ветвь (nil, в случае, если перебазируется текущая ветвь).

**`post-merge`**

Запускается после успешного слияния. Имеет один аргумент:

`$*[0]` — флаг, указывающий на тип слияния (0 — обычное, 1 ­ слияние через
сжатие).

**`post-checkout`**

Запускается после выписки. Имеет три аргумента:

`$*[0]` — полный хэш последней правки в текущей ветви;

`$*[1]` — полный хэш последней правки в выписанной ветви;

`$*[2]` — флаг, указывающий на тип выписки (0 — выписка файла, 1 — выписка
ветви).

##Серверные закрепленные действия
{: id="Серверные_закрепленные_действия"}

Серверные закрепленные сценарии содержатся в каталоге `hooks/` в удаленном репозитории.

**`pre-receive`**

Запускается после получения обновлений от клиента, перед добавлением этих
обновлений в репозиторий. Будет выполнен один раз, вне зависимости от того,
сколько ветвей предполагается обновить. Позволяет отклонять обновления
удаленного репозитория. Если сценарий возвращает „1“ (`exit 1`), то обновления
не произойдет, если „0“ (`exit 0`), то обновление пройдет успешно. Не имеет
аргументов.

**`update`**

Запускается после получения обновлений от клиента, перед добавлением этих
обновлений в репозиторий. Будет выполнен столько раз, сколько ветвей
предполагается обновить. Позволяет отклонять обновление определенных ветвей.
Если сценарий возвращает „1“ (`exit 1`), то обновления не произойдет, если „0“
(`exit 0`), то обновление пройдет успешно. Имеет три аргумента:

`$*[0]` — полное имя ветви, предполагаемой для обновления;

`$*[1]` — хэш текущей правки для данной ветви;

`$*[2]` — хэш последней правки для данной ветви.

**`post-receive`**

Запускается после добавления обновлений, полученных от клиента. Будет выполнен
один раз, вне зависимости от того сколько ветвей было обновлено. Не имеет
аргументов.

#Выставление
{: id="Выставление"}

    git add <имя_файла> - выставить файл для передачи.

      git add -i - войти в интерактивный режим.

      git add -p - войти в режим правки.

      git add -e - открыть текстовый редактор для редактирования выставленных изменений.

    git reset HEAD <имя_файла> - снять выставленный файл.

    git rm <имя_файла> - выставить файл для удаления.

      git rm <имя_файла> --cached - удалить файл из репозитория, но не из проекта.

    git mv <имя_файла> <новое_имя_файла> - выставить файл для переименования.

#Откладывание изменений
{: id="Откладывание_изменений"}

    git stash - отложить сделанные изменения.

      git stash list - вывести список отложенных изменений.

      git stash show stash@{<n>} - посмотреть краткие сведения об указанном отложенном изменении.

        git stash show -p stash@{<n>} - посмотреть подробные сведения об указанном отложенном изменении.

      git stash apply stash@{<n>} - добавить n-ное отложенное изменение.

      git stash drop stash@{<n>} - удалить n-ное отложенное изменение из списка.

      git stash branch <имя> stash@{<n>} - создать ветвь из отложенного изменения и удалить последнее.

#Передача
{: id="Передача"}

**`git commit`**

_зафиксировать изменения для всех выставленных файлов_

**`git commit -m`** _`message`_

_зафиксировать изменения одновременно с добавлением журнальной записи_

**`git commit`** _`file`_

_зафиксировать изменения только для указанного файла, вне зависимости от того, является он выставленным или нет_

**`git commit -a`**

_зафиксировать изменения для всех файлов, как выставленных так и не выставленных_

#Исправление и откат сделанных передач
{: id="Исправление_и_откат_сделанных_передач"}

    git commit --amend -m <новая_запись> - изменить журнальную запись для последней передачи, а так же добавить выставленные изменения в последнюю передачу, если таковые имеются.

    git commit --amend -C HEAD - добавить выставленные изменения в уже совершенную передачу.

    git commit --amend -a -C HEAD - добавить невыставленные изменения в уже совершенную передачу.

    git revert <хэш> - осуществить передачу, отменяющую изменения в указанной передачи. Если необходимо осуществить отменяющую передачу не для последней передачи, то нужно последовательно выполнить данный тип передачи несколько раз, начиная с последней передачи.
      git revert -n <хэш> - выставить отмененные изменения. При пакетной отмене, можно использовать идиому: git revert -n HEAD; git revert -n HEAD^; git revert -n HEAD^^ и т. д.
      git revert --no-edit <хэш> - не запускать редактор при выполнении отменяющей передачи. В этом случае в качестве журнального сообщения будет присутствовать стандартная запись.

    git reset <хэш> - переместится в истории изменений до указанной передачи, удалив все последующие, не выставляя все осуществленные изменения.

      git reset --soft <хэш> - переместиться в истории изменений до указанной передачи, удалив все последующие, выставив все осуществленные изменения.

      git reset --hard <хэш> - переместиться в истории изменений до указанной передачи, удалив все последующие.

    git filter-branch --tree-filter 'rm -f <файл>' <ветвь> - удалить указанный файл во всех передачах ветви. Будет создана резервная копия. Удалить её можно следующей командой.

      git update-ref -d <ветвь> <хэш>

    Если затем попытаться повторно удалить некий файл уже из другой ветви, то команда возвратит ошибку, сообщающую о невозможности перезаписать резервную копию. Для того, чтобы форсировать перезапись нужно добавить опцию -f к команде.

      git filter-branch -f --tree-filter 'rm -f <файл>' <ветвь>

      git filtrer-branch --tree-filter 'rm -f <файл>' -- --all - удалить указанный файл во всех передачах всех ветвей.


#Журналирование
{: id="Журналирование"}

    git log - просмотр всех сделанных передач.

      git log --format='<строка_форматирования>' - вывести журнал передач и форматировать вывод.
      git log -<число> - просмотр определенного количества последних передач.
      git log <хэш> - просмотр журнала до указанной передачи.
      git log [<хэш> | <метка>]..[<хэш> | <метка> | HEAD | ''] - просмотр журнала в указанном интервале без включения в него первого хэша.

        git log --oneline --left-right <ветвь_1>...<ветвь_2> - просмотреть изменения в указанных ветвях имеющих общего предка и вывести указатели на ветвь в соответствующих передачах.

      git log --since='[<время> | <год-число.месяц>]' - просмотр журнала за указанное время, либо начиная с указанной даты.
      git log --before='[<время> | <год-число.месяц>]' - просмотр журнала до указанного времени или даты.

      git log -p - просмотр всех сделанных передач вместе со сделанными изменениями в файлах.

      git log --graph - просмотр журнала передач с графическим отображением ветвей.

      git log -- <путь> - просмотр изменений указанного файла.

      git log <целевая_ветвь> {--not <базовая_ветвь> | ^<базовая_ветвь>} - просмотр всех передач в целевой ветви, исключая передачи в базовой.

      git log --graph --oneline --decoration=short --all - просмотреть все передачи во всех ветвях в графическом режиме, отображая каждую передачу на одной строке, показав имена всех ветвей.

    git rev-parse <метка> - просмотр полного хэша для отмеченной передачи.

    git show <метка> - просмотр данных об указанной метки вместе с данными о передачи, которая была отмечена.


    Cписок символов форматирования:
      %h - укороченный хэш;
      %s - заголовок передачи;
      %b - тело передачи;
      %n - новая строка.

    Список спецсимволов:
      ^        - текущая передача минус один;
      ^<число> - следующий предок текущей передачи (если предков несколько);
      ~<число> - текущая передача минус указанное чилсло.

#Просмотр изменений
{: id="Просмотр_изменений"}

**`git diff`**

_просмотреть изменения во всех файлах относительно индекса_

**`git diff --staged`**

_просмотреть изменения между выставленными файлами и файлами в репозитории_

**`git diff --text`**

_рассматривать двоичные файлы как текстовые (по умолчанию, git игнорирует двоичные файлы и не выводит изменения в них)_

**`git diff --stat`**

_вывести сводный отчет по сделанным изменениям_

**`git diff --check`**

_проверить файл на наличие завершающих пробелов_

**`git diff -U`**_`number`_

_установить количество отображаемых строк до и после изменённой строки_

**`git diff`** _`hash`_

_просмотреть изменения во всех файлах относительно указанной передачи_

**`git diff`** _`hash`_ _`file`_

_просмотреть изменения в конкретном файле относительно указанной передачи_

**`git diff`** _`tag..tag`_

_просмотреть изменения в указанном интервале передач_

**`git diff`** _`base_branch..target_branch`_

_просмотреть изменения между целевой ветвью и общим предком базовой и целевой ветвей_

**`git difftool`**

_просмотреть изменения в специализированной программе_


**`git difftool -y`**

_не выводить подтверждающий запрос при запуске программы просмотра изменений_

**`git blame`** _`file`_

_просмотреть изменения в файле с включением в вывод хэша, автора, даты и прочей информации_

**`git blame -L`** _`starting_line`_**`,`**_`{ending_line | `_ **`-`**_`offset`_ _`|`_ **`+`**_`offset`_ _`}`_ _`file`_

_отобразить только указанные строки в просматриваемом файле_

_Интервал задается указанием номера начальной строки и (опционально) номером конечной строки или количеством строк до или после начальной._

**`git blame`** _`hash{ `_ **`^`** _`|`_ **`~`**_`offset }`_ **`--`** _`file`_

_просмотреть изменения в файле до указанной передачи и не включать все последующие_

_Передача идентифицируется хэшем или отклонением от передачи с указанным хэшем (`^` — „указанная, минус один“, `~n` — „указанная, минус n“)_

**`git blame`** _`hash`_**`..`**_`hash`_ **`--`** _`file`_

_просмотреть изменения в указанном интервале передач_


#Ветвление
{: id="Ветвление"}

    git branch - показать все текущие ветви и отметить рабочую.
      git branch -v - показать все ветви, отметить текущую и вывести последнюю передачу для каждой ветви.
      git branch -r - показать все ветви в удаленном репозитории.
      git branch <имя_ветви> <имя_родительской_ветви> - создать ветвь.
      git branch <имя_новой_ветви> <имя_метки> - восстановить ветвь с указанной метки.
      git branch -d <имя_ветви> - удалить ветвь. Ветвь должна быть слита.
        git branch -rd <имя_ветви> - удалить удаленную ветвь.
      git branch -D <имя_ветви> - удалить ветвь вне зависимости от того, слита она или нет.
      git branch -m <прежнее_имя> <новое_имя> - переименовать ветвь.

    git checkout <имя_ветви> - выписать указанную ветвь.
      git checkout -b <имя_новой_ветви> <имя_родительской_ветви> - создать новую ветвь и сразу же переключиться на неё.

#Слияние
{: id="Слияние"}

    git merge <имя_ветви> - осуществить прямое слияние текущей ветви с указанной.
      git merge --no-commit <имя_ветви> - выствить слияние.
      git merge --squash <имя_ветви> - выставить объединенные передачи указанной ветви для текущей.
      git cherry-pick <укороченный_дайджест> - осуществить передачу, помеченную дайджестом, для текущей ветви.
      git cherry-pick {-n | --no-commit} <укороченный_дайджест> - выставить передачу, помеченную дайджестом, для текущей ветви.

    git mergetool <программа_сравнения> - использовать программу сравнения для разрешения конфликтов слияния.

    git merge-base <ветвь_1> <ветвь_2> - найти общего предка между двумя ветвями.

#Перебазирование
{: id="Перебазирование"}

    git rebase <базовая_ветвь> <целевая_ветвь> - перебазировать целевую ветвь в конец базовой.
      git rebase <ветвь> - перебазировать текущую ветвь в конец указанной.

    git rebase --onto <базовая_ветвь> <ветвь_посредник> <целевая_ветвь> - перебазировать целевую ветвь в конец базовой, исключая предка в ветви посреднике.
      git reabase --onto <базовая_ветвь> <ветвь_посредник> - перебазировать текущую ветвь в конец базовой, исключая предка в ветви посреднике. 

    git rebase -i <хэш> - войти в интерактивный режим для изменения порядка передач.

#Метки
{: id="Метки"}

    git tag <метка> <имя_ветви> - добавить легковесную метку для указанной ветви.
      git tag <метка> <укороченный_дайджест_передачи> - установить метку для одной из предыдущих передач.
      git tag -a <метка> -m <описание> - добавить аннотированную метку для текущей ветви.
      git tag - возвратить список меток.
      git tag -d <метка> - удалить указанную метку.

#Работа с удаленными репозиториями
{: id="Работа_с_удаленными_репозиториями"}

    git clone <URL> - клонировать репозиторий в локальный каталог.

    git remote add <имя> <URL> - добавить удаленный репозиторий.
    git remote -v - просмотр всех удаленных репозиториев и их URL.
    git remote rm <имя> - удалить указанный удаленный репозиторий.

    git fetch {<url> | <локальное_имя>} - скачать объекты из указанного удаленного репозитория и не сливать их с имеющимися в локальном репозитории.

    git pull {<url> | <локальное_имя>} - скачать объекты из указанного удаленного репозитория и слить их с имеющимися в локальном репозитории.

    git push [<имя_удаленного_репозитория>] - обновить удаленный репозиторий.
      git push --dry-run - имитировать обновление репозитория.
      git push <репозиторий> <ветвь> - обновить удаленный репозиторий, добавив в него только указанную ветвь.
      git push <репозиторий> <ветвь>:<имя_в_удаленном_репозитории> - обновить удаленный репозиторий, добавив в него указанную ветвь, но сохранив её под другим именем.
      git push <удаленный_репозиторий> :<удаляемая_ветвь> - удалить указанную ветвь из удаленного репозитория.
      git push -f - осуществить настойчивое обновление.
      git push --tags - добавить в репозиторий все имеющиеся метки.

      git request-pull <начальная_ссылка> <url_репозитория> [<конечная_ссылка>] - вывысти на экран сводную статистику по передачам, ожидающим вытягивания со стороны менеджера.

#Субмодули
{: id="Субмодули"}

    git submodule - просмотреть субмодули.
      git submodule add <репозиторий> <имя> - создать директорую с указанным именем и добавить в неё указанный репозиторий.
      git submodule init <имя> - инициализировать (добавить запись о субмодуле в .git/config) указанный субмодуль.
      git submodule update <имя> - обновить субмодуль.

#Архивирование
{: id="Архивирование"}

    git archive --format=<tar | zip> --prefix=<имя>/ <ветвь> - поместить все файлы проекта в директорию с указанным именем и создать архив указанного формата.

      git archive --format=tar --prefix=<имя>/ <ветвь> | gzip > <имя>.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата tar и сжать этот архив, сохраняя в файле .tar.gz.

      git archive --prefix=<имя>/ <ветвь> | gzip > `git describe --tags master`.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата по умолчанию (tar) и сжать этот архив, сохраняя в файле с именем являющимся выводом команды git-describe, добавляя расширение .tar.gz.

        git describe --tags <ветвь> - показать самую последнюю созданную метку, учитывая неаннотированные метки. Вывод команды имеет следующий формат: <имя_тэга>-<количество_сделанных_передач>-g<хэш_последней_передачи>. "g" в выводе означает, что используется VCS git.

#Патчи
{: id="Патчи"}

    git format-patch [<начальная_передача> | <начальная_передача>..<конечная_передача>] - подготовить файлы с патчами для отправки по электронной почте. Использовать либо все передачи начиная с начальной до текущей, либо все передачи в указанном интервале.

      git format-patch -o <директория_вывода> - подготовить файлы патчей и сохранить их в указанной директории.

      git format-patch --stdout - подготовить файлы патчей и вывести их содержимое в консоль.

    git apply <файл_патча> - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданные с помощью следующих команд.

      $ git diff <старт-метка>..<финиш-метка> > <имя>.patch
      $ git log -p <старт-метка>..<финиш-метка> > <имя>.patch

    git am {<mbox-файл> | <файл_патча>} - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданный с помощью следующей команды.

      $ git format patch <старт-метка>..<финиш_метка> -о <директория>

      git am -i {<mbox-файл> | <файл-патча>} - добавить изменеия в файлы проекта в интерактивном режиме.

      git am -3 {<mbox-файл> | <файл-патча>} - добавить изменения в файлы проекта. При возникновении конфлика добавить конфликтные маркеры в файлы с конфликтами.

#Отправка патчей по электронной почте
{: id="Отправка_патчей_по_электронной_почте"}

Для отправки почты необходимо установить пакет sendmail.

    git send-email --from=<адрес_отправителя> --to=<адрес_получателя> {<список_файлов> | <директория>} - отправить на указанный адрес либо перечисленные файлы патчей, либо все файлы в указанной директории.

       Настройка git send-email
      --------------------------
        # ~/.gitconfig
        [sendemail]
          smtpserver = <адрес_smtp-сервера> (smtp.gmail.com)
          smtpserverport = <порт_smpt-сервера> ({587 | 465})
          smtpencryption = <криптографический_протокол> ({tls | ssl})
          smtpuser = <логин> (login@gmail.com)
          smtppass = <пароль> (password)
          from = <адрес_отправителя>
          to = <адрес_получателя>
          confirm = {always | never}

    git format-patch --stdout {<начальная_передача> | <интервал>} | git imap-send - загрузить файлы патчей в директорию с черновиками на почтовом сервере.

       Настройка git imap-send
      -------------------------
        # ~/.gitconfig
        [imap]
          folder = <директория_с_черновиками> ([Gmail]/Черновики)
          host = <адрес_почтового_сервера> ({imaps:// | imap://}imap.gmail.com)
          port = <порт_почтового_сервера> ({993 | 143})
          user = <логин> (login@gmail.com)
          pass = <пароль> (password)
          sslverify = <логическое_значение> ({false | true})

#Восстановление и очистка
{: id="Восстановление_и_очистка"}

    git gc - удалить ненужные файлы и произвести оптимизацию локального репозитория.

    git reflog - отобразить журнал изменений.

#Пошаговый поиск проблемных передач
{: id="Пошаговый_поиск_проблемных_передач"}

    git bisect start <проблемная_передача> <беспроблемная_передача> - начать пошаговый поиск в указанном интервале.

      git bisect bad  - отметить передачу как проблемную.
      git bisect good - отметить передачу как беспроблемную.

      git bisect reset - закончить пошаговый поиск.

        git bisect reset <метка> - закончить пошаговый поиск и установить указатель HEAD на отмеченную передачу.

#Gitosis
{: id="Gitosis"}

##Порядок установки менеджера репозиториев Gitosis
{: id="Порядок_установки_менеджера_репозиториев_Gitosis"}

\1. На удаленной машине создать пользователя git.

    # adduser \
    > --system \
    > --group \
    > --disabled-password \
    > --shell /bin/sh \
    > --home /home/git \
    > git

\2. На локальной машине создать публичный ключ для использования вместе с SSH.

    $ ssh-keygen -t rsa

Если не указывать пароль для ключа, то при подключении к SSH-серверу система не будет требовать аутентификации. Обе части ключа (публичная и частная) будут размещены в директории ~/.ssh

\3. Скопировать публичную часть ключа (\<имя_ключа\>.pub) на сервер в директорию /путь/к/публичному/ключу.

\4. Инициализировать Gitosis на удаленной машине.

    # su git -c 'gitosis-init < /путь/к/публичному/ключу'

\4.1 Добавить алиас для IP-адреса удаленной машины в файл /etc/hosts локальной машины.

    $ vim /etc/hosts
    $ cat /etc/hosts
    ...
    192.168.1.14 pavel-server
    ...

##Настройка Gitosis
{: id="Настройка_Gitosis"}

1) Склонировать конфигурацоный репозиторий Gitosis на локальную машину. Если для пользователя был установлен пароль, то он будет запрошен.

    $ git clone git@pavel-server:gitosis-admin.git

или

    $ git clone ssh://git@pavel-server/gitosis-admin.git

2) Перейти в директорию gitosis-admin.git и открыть файл gitosis.conf.

    $ cd gitosis-admin
    $ vim gitosis.conf

3.1) Для настройки доступа к конфигурации Gitosis добавить нового пользователя в графу 'members' секции '\[group gitosis-admin\]'. Для добавления нескольких пользователей, необходимо перечислить их в данной графе, разделяя пробелами. Не стоит добавлять лишние пробелы в конфигурационный файл во избежании возникновения ошибки интерпретатора языка Perl при отправке изменений на сервер*.

    $ cat gitosis.conf
    [group gitosis-admin]
    writable = gitosis-admin
    members = <пользователь_1> <пользователь_2> ...

*Hо не.

    [group gitosis-admin]
      writable = gitosis-admin
      members  = <пользователь_1> <пользователь_2> ...

3.2) Для добавления нового частного репозитория добавить новую секцию.

    [group <группа_чтение-запись>]
    writable = <репозиторий_а>
    members = <пользователь_1> <пользователь_2> ...

Все перечисленные пользователи будут иметь право доступа и записи в созданный репозиторий.

    [group <группа_только_чтение>]
    readonly = <репозиторий_а>
    members = <пользователь_3> <пользователь_4> ...

Здесь, все перечисленные пользователи смогут только клонировать указанный репозиторий. Они не будут иметь право записи.

    [repo <репозиторий_а>]
    daemon = yes

Добавив данную секцию можно открыть публичный доступ к указанному репозиторию. Для того, чтобы пользователи могли скачивать этот репозиторий необходимо запустить git-daemon на удаленной машине.

    # su git -c "git daemon --base-path=<git-home>/repositories"

Таким образом будет открыт общий доступ к данному репозиторию с правом чтения, но не записи. Непривелигированные пользователи будут иметь возможность скачивать репозиторий по протоколу git.

    $ git clone git://<хост>/<путь>.git

Например:

    $ git clone git://pavel-server/project.git

#Примеры
{: id="Примеры"}

##Создание локального репозитория
{: id="Создание_локального_репозитория"}

    1. $ mkdir project; cd project; git init
    2. $ touch README; git add .; git commit -m 'init'
    3. $ mkdir ../project.git; git init --bare ../project.git
    4. $ git remote add origin file://<путь_к_project.git>
    5. $ git push origin master

##Добавление субмодуля
{: id="Добавление субмодуля"}

    1. $ git submodule add <путь> <имя>
    2. $ git submodule init <имя>

##Добавления субмодуля в составе склонированного репозитория
{: id="Добавления_субмодуля_в_составе_склонированного_репозитория"}

    1. $ git submodule init <имя>
    2. $ git submodule update <имя>

##Исправление журнальной записи передачи
{: id="Исправление_журнальной_записи_передачи"}

    1. $ git rebase -i <хэш_родительской_передачи_для_проблемной>
    2. Откроется текстовый редактор с перечнем передач.
    3. Сменить метки pick на edit во всех проблемных передачах.
    4. Сохранить изменения и закрыть редактор.
    5. $ git commit --amend
    6. Откроется редактор с текстом журнальной записи.
    7. Исправить запись, сохранить изменения, закрыть редактор.
    8. $ git rebase --continue
    9. Повторить шаги 5-8 для всех проблемных передач.

##Разбивка одной передачи на несколько
{: id="Разбивка_одной_передачи_на_несколько"}

    1. $ git rebase -i <метка>
    2. Откроется текстовый редактор с перечнем передач.
    3. Сменить метку pick на edit в проблемной передаче.
    4. $ git reset HEAD^
    5. Измененный файл окажется в невыставленной области.
    6. $ git add -e
    7. Отредактировать файл, добавляя необходимые изменения.
    8. $ git commit
    9. Повторить шаги 6-8 для всех изменений.
    10. $ git rebase --continue

<!-- vim: set textwidth=80 colorcolumn=80: -->
