---
title: Git
---

#Содержание
{: id="Содержание"}

[Глоссарий](#Глоссарий)

[Элементы](#Элементы)

[Конфигурация](#Конфигурация)

[Создание нового репозитория](#Создание_нового_репозитория)

[Атрибуты](#Атрибуты)

[Закрепленные сценарии](#Закрепленные_сценарии)

[Выставление](#Выставление)

[Откладывание правок](#Откладывание_правок)

[Фиксация правок](#Фиксация_правок)

[Исправление и откат сделанных передач](#Исправление_и_откат_сделанных_передач)

[Журналирование](#Журналирование)

[Просмотр изменений](#Просмотр_изменений)

[Ветвление](#Ветвление)

[Слияние](#Слияние)

[Перебазирование](#Перебазирование)

[Метки](#Метки)

[Работа с удаленными репозиториями](#Работа_с_удаленными_репозиториями)

[Субмодули](#Субмодули)

[Архивирование](#Архивирование)

[Патчи](#Патчи)

[Отправка патчей по электронной почте](#Отправка_патчей_по_электронной_почте)

[Восстановление и очистка](#Восстановление_и_очистка)

[Пошаговый поиск проблемных передач](#Пошаговый_поиск_проблемных_передач)

[Gitosis](#Gitosis)

[Примеры](#Примеры)

#Глоссарий
{: id="Глоссарий"}

**commit**

_фиксация правок в файле_

**to commit**

_зафиксировать правки в файле_

**staged area**
{: id="staged_area"}

_область выставления_, тж. _индекс_

**unstaged area**
{: id="unstaged_area"}

_невыставленная область_; _рабочая область_

**to stage**

_выставить файл_; _переместить файл в индекс_

**to unstage**

_отменить выставление_; _вернуть файл в рабочую область_; _удалить файл из
индекса_

**tracked file**
{: id="tracked_file"}

_отслеживаемый файл_; _включенный файл_ (в репозиторий)

**untracked file**
{: id="untracked_file"}

_неотслеживаемый файл_; _невключенный файл_

**to track**

_включить файл_ (в репозиторий) для отслеживания изменений в нём

#Элементы
{: id="Элементы"}

**ссылка** (_reference_, _ref_)
{: id="ссылка"}

указатель на последнюю версию цепочки правок

#Конфигурация
{: id="Конфигурация"}

[Команды конфигурации](#Команды_конфигурации)

[Опции](#Опции)

##Команды конфигурации
{: id="Команды_конфигурации"}

**`git config --system`** _`option`_ _`value`_

_системная (/etc/gitconfig)_

**`git config --global`** _`option`_ _`value`_

_глобальная (~/.gitconfig)_

**`git config`** _`option`_ _`value`_

_локальная (.git/config)_

##Опции
{: id="Опции"}

**`alias.`**_`old_command`_ _`new_command`_

_добавить замену для стандартной команды_

_При замене глобальной команды следует поставить „!“ перед заменяемой командой:_

_`git config --global alias.visual'!gitk'`_

**`core.editor`** _`editor`_

_добавить текстовый редактор_

**`core.pager`** _`pager`_

_установить пэйджер. Можно отключить использование пэйджера, передав пустую строку (`''`) в качестве значения_

**`core.quotepath false`**

_запретить вывод имен файлов в формате Unicode в виде числовых кодов при выполнении `git status`_

**`merge.tool`** _`merge_tool`_

_добавить инструмент сравнения файлов_

**`commit.template`** _`template`_

_установить шаблон для записи передачи_

**`core.excludesfile`** _`path`_

_установить внешний файл с исключениями_

**`help.autocorrect 1`**

_установить автоматическое исправление опечаток_

**`color.ui`** _`{true | false | always}`_

_настроить цветной вывод. При установке опции always, цветной вывод будет присутствовать даже при перенаправлении данных в файл или другой команде_

#Создание нового репозитория
{: id="Создание_нового_репозитория"}

**`git init`**

_ининциализировать репозиторий_

**`git status`**

_вывести текущий статус_

**`git checkout --`** _`filename`_

_откатить сделанные в файле правки_

#Атрибуты
{: id="Атрибуты"}

Атрибуты задаются в файлах _`./.gitattributes`_ или _`./.git/info/attributes`_.

Формат задания атрибутов в указанных выше файлах следующий: _`path attribute`_.

_`path`_ **`export-ignore`**

_не добавлять указанные файлы и каталоги в архив при экспорте с помощью_ **`git
archive`**

#Закрепленные сценарии
{: id="Закрепленные_сценарии"}

[Клиентские закрепленные сценарии](#Клиентские_закрепленные_сценарии)

[Сценарии, связанные с фиксацией правок](#Сценарии_связанные_с_фиксацией_правок)

[Сценарии, связанные с добавление патчей](#Сценарии_связанные_с_добавление_патчей)

[Серверные закрепленные сценарии](#Серверные_закрепленные_сценарии)

Файлы с закрепленными сценариями содержатся в каталоге `.git/hooks`.

##Клиентские закрепленные сценарии
{: id="Клиентские_закрепленные_сценарии"}

_пусто_

##Сценарии, связанные с фиксацией правок
{: id="Сценарии_связанные_с_фиксацией_правок"}

**`pre-commit`**

Запускается сразу же после команды `git commit` и перед запуском текстового
редактора. Если данный сценарий возвращает „0“ (`exit 0`), то после него будет
запущен текстовый редактор, если „1“ (`exit 1`), то фиксация правки будет
отменена.

**`prepare-commit-msg`**

Запускается перед запуском текстового редактора, но сразу же после создания
текстового сообщения по умолчанию. Позволяет изменять текстовое сообщение по
умолчанию. Имеет три аргумента:

`$*[0]` — файл с текстовым сообщением по умолчанию;

`$*[1]` — тип правки `{commit | template | squash}`;

`$*[2]` — хэш правки.

**`commit-msg`**

Выполняется после закрытия текстового редактора и перед фиксацией правки. Может
быть использован для проверки журнальной записи на соответствие некоторым
критериям. Имеет один аргумент:

`$*[0]` — файл с текстовым сообщением.

**`post-commit`**

Запускается после успешной фиксации правки.

##Сценарии, связанные с добавление патчей
{: id="Сценарии_связанные_с_добавление_патчей"}

**`applypatch-msg`**

Запускается перед добавлением патча командой `git am`. Если сценарий возвратит
„1“ (`exit 1`), то патч добавлен не будет, если „0“ (`exit 0`), то патч будет
добавлен. Имеет один аргумент:

`$*[0]` — временный файл, содержащий журнальную запись.

**`pre-applypatch`**

Запускается перед добавлением патча командой `git am`. Позволяет проверить
некоторые изменения в файлах проекта. Если сценарий возвратит „1“ (`exit 1`), то
изменения в файлах будут выставлены, если „0“ (exit 0), то патч будет добавлен.
Не имеет аргументов.

**`post-applypatch`**

Запускается по завершению добавления патча командой `git am`. Не позволяет
проводить какие-либо проверки и отменять обновление проекта. Не имеет
аргументов.

##Сценарии, связанные с перебазированием, слиянием и выпиской
{: id="Сценари_связанные_с_перебазированием_слиянием_и_выпиской"}

**`pre-rebase`**

Запускается перед перебазированием. Позволяет проверить некоторые условия перед
этой операцией. Если сценарий возвратит „1“ (`exit 1`), то перебазирование не
будет осуществлено, если „0“ (`exit 0`), то будет. Может иметь два, либо один
аргумент:

`$*[0]` — базовая ветвь;

`$*[1]` — целевая ветвь (nil, в случае, если перебазируется текущая ветвь).

**`post-merge`**

Запускается после успешного слияния. Имеет один аргумент:

`$*[0]` — флаг, указывающий на тип слияния (0 — обычное, 1 ­ слияние через
сжатие).

**`post-checkout`**

Запускается после выписки. Имеет три аргумента:

`$*[0]` — полный хэш последней правки в текущей ветви;

`$*[1]` — полный хэш последней правки в выписанной ветви;

`$*[2]` — флаг, указывающий на тип выписки (0 — выписка файла, 1 — выписка
ветви).

##Серверные закрепленные сценарии
{: id="Серверные_закрепленные_сценарии"}

Серверные закрепленные сценарии содержатся в каталоге `hooks/` в удаленном репозитории.

**`pre-receive`**

Запускается после получения обновлений от клиента, перед добавлением этих
обновлений в репозиторий. Будет выполнен один раз, вне зависимости от того,
сколько ветвей предполагается обновить. Позволяет отклонять обновления
удаленного репозитория. Если сценарий возвращает „1“ (`exit 1`), то обновления
не произойдет, если „0“ (`exit 0`), то обновление пройдет успешно. Не имеет
аргументов.

**`update`**

Запускается после получения обновлений от клиента, перед добавлением этих
обновлений в репозиторий. Будет выполнен столько раз, сколько ветвей
предполагается обновить. Позволяет отклонять обновление определенных ветвей.
Если сценарий возвращает „1“ (`exit 1`), то обновления не произойдет, если „0“
(`exit 0`), то обновление пройдет успешно. Имеет три аргумента:

`$*[0]` — полное имя ветви, предполагаемой для обновления;

`$*[1]` — хэш текущей правки для данной ветви;

`$*[2]` — хэш последней правки для данной ветви.

**`post-receive`**

Запускается после добавления обновлений, полученных от клиента. Будет выполнен
один раз, вне зависимости от того сколько ветвей было обновлено. Не имеет
аргументов.

#Выставление
{: id="Выставление"}

**`git add`** _`file`_

_выставить файл для фиксации правок_

**`git add -i`**

_выставить желаемые файлы посредством их выбора в интерактивном режиме_

Запустится интерактивная утилита. Потребуется выбрать файлы.

**`git add -p`**

_выставить файлы путем последовательного выбора или отката желаемых правок в
интерактивном режиме_

Запуститися интерактивная утилита. Потребуется выбрать _правки_.

**`git add -e`**

_выставить файлы путем выбора или отката желаемых правок в текстовом редакторе_

Запустится текстовый редактор. Потребуется удалить ненужные правки путем
непосредственного исключения их из текста загруженного документа.

**`git reset HEAD`** _`file`_

_снять выставленный файл_

Файл должен находиться в [индексе](#staged_area).

**`git checkout --`** _`file`_

_отменить правки в указанном файле_

Файл должен находиться в [рабочей области](#unstaged_area).

**`git rm`** _`file`_

_выставить файл для удаления_

Файл должен быть [включен](#tracked_file) в репозиторий. В [противном случае](#untracked_file), следует использовать
средства операционной системы для удаления файла (e. g. `rm file`).

**`git rm --cached`** _`file`_

_отменить добавление нового неотслеживаемого файла в индекс и вернуть его в
рабочую область_

**`git mv`** _`old_name`_ _`new_name`_

_выставить файл для переименования_

#Откладывание правок
{: id="Откладывание_правок"}

**`git stash`**

_отложить сделанные правки_

**`git stash list`**

_вывести список отложенных правок_

**`git stash show stash@{`**_`n`_**`}`**

_вывести краткие сведения об указанной отложенной правке_

**`git stash show -p stash@{`**_`n`_**`}`**

_вывести подробные сведения об указанной отложенной правке_

**`git stash apply stash@{`**_`n`_**`}`**

_добавить n-ую отложенную правку_

**`git drop stash@{`**_`n`_**`}`**

_удалить n-ую отложенную правку_

**`git stash branch`** _`name`_ **`stash@{`**_`n`_**`}`**

_создать ветвь из отложенной правки и удалить последнее_

#Фиксация правок
{: id="Фиксация_правок"}

**`git commit`**

_зафиксировать изменения для всех выставленных файлов_

**`git commit -m`** _`message`_

_зафиксировать изменения одновременно с добавлением журнальной записи_

**`git commit`** _`file`_

_зафиксировать изменения только для указанного файла, вне зависимости от того, является он выставленным или нет_

**`git commit -a`**

_зафиксировать изменения для всех файлов, как выставленных так и не выставленных_

#Исправление и откат сделанных передач
{: id="Исправление_и_откат_сделанных_передач"}

    git commit --amend -m <новая_запись> - изменить журнальную запись для последней передачи, а так же добавить выставленные изменения в последнюю передачу, если таковые имеются.

    git commit --amend -C HEAD - добавить выставленные изменения в уже совершенную передачу.

    git commit --amend -a -C HEAD - добавить невыставленные изменения в уже совершенную передачу.

    git revert <хэш> - осуществить передачу, отменяющую изменения в указанной передачи. Если необходимо осуществить отменяющую передачу не для последней передачи, то нужно последовательно выполнить данный тип передачи несколько раз, начиная с последней передачи.
      git revert -n <хэш> - выставить отмененные изменения. При пакетной отмене, можно использовать идиому: git revert -n HEAD; git revert -n HEAD^; git revert -n HEAD^^ и т. д.
      git revert --no-edit <хэш> - не запускать редактор при выполнении отменяющей передачи. В этом случае в качестве журнального сообщения будет присутствовать стандартная запись.

    git reset <хэш> - переместится в истории изменений до указанной передачи, удалив все последующие, не выставляя все осуществленные изменения.

      git reset --soft <хэш> - переместиться в истории изменений до указанной передачи, удалив все последующие, выставив все осуществленные изменения.

      git reset --hard <хэш> - переместиться в истории изменений до указанной передачи, удалив все последующие.

    git filter-branch --tree-filter 'rm -f <файл>' <ветвь> - удалить указанный файл во всех передачах ветви. Будет создана резервная копия. Удалить её можно следующей командой.

      git update-ref -d <ветвь> <хэш>

    Если затем попытаться повторно удалить некий файл уже из другой ветви, то команда возвратит ошибку, сообщающую о невозможности перезаписать резервную копию. Для того, чтобы форсировать перезапись нужно добавить опцию -f к команде.

      git filter-branch -f --tree-filter 'rm -f <файл>' <ветвь>

      git filtrer-branch --tree-filter 'rm -f <файл>' -- --all - удалить указанный файл во всех передачах всех ветвей.

#Журналирование
{: id="Журналирование"}

**`git log`**

_вывести список всех сделанных правок_

**`git log --format=`**_`format_string`_

_задать пользовательский формат вывода_

Cписок символов форматирования:

`%h` - укороченный хэш, идентифицирующий правку;

`%s` - загловок журнальной записи;

`%b` - содержимое журнальной записи;

`%n` - новая строка.

**`git log -`**_`number`_

_ограничить перечень выводимых правок заданным числом_

**`git log`** _`hash`_

_не отображать правки после заданной указанным хэшем_

**`git log`** _`old_hash`_**`..`**_`[ new_hash ]`_

_вывести список правок в заданном интервале_

Правка, соответствующая нижней границе не будет включена в вывод. Верхняя
граница может быть опущена. В этом случае, таковой будет считаться последняя
сделанная правка.

**`git log --oneline --left-right --boundary `** _`left_branch`_**`...`**_`right_branch`_

_вывести список правок для двух ветвей с общей правкой_

В выводе под каждую правку будет выделена одна строка (`--oneline`). Вывод будет
содержать правки обоих ветвей, а так же общую правку-родителя (`--boundary`).
Информация будет выведена в один столбик. Каждую запись будет предварять либо
стрелка влево, либо стрелка вправо, в зависимости от того куда была внесена
правка, в левую или в правую ветвь (`--left-right`). Общая правка будет помечена
знаком дефис (`-`).

**`git log`** _`{`_ **`--since=`** _`|`_ **`--until=`** _`}datetime`_

_вывести список правок с/до указанной даты-времени_

Формат даты-времени может быть разным. Например:

`12012019` — 12 декабря 2019 года;

`1201` — 12 декабря текущего года;

`12.01.2019 13:00:04` — 12 декабря 2019 года 13:00:04.

**`git log -p`**

_вывести список правок вместе со сделанным изменениями_

**`git log --all --graph`**

_отобразить историю правок во всех ветвях в виде графов_

**`git log --`** _`file`_

_отобразить историю правок только для указанного файла_

**`git log`** _`branch`_ _`[`_ **`--not`** _`base_branch`_ _`|`_ **`^`** _`base_branch`_ _`]`_

_отобразить историю правок для указанной ветви_

Посредство опции `--not` имеется возможность исключить из вывода правки,
сделанные в ветви на которой основана указанная ветвь.

**`git log --decorate=`**_`format`_

_задать формат отображения [ссылок](#ссылка)_

Перечень возможных значений:

`short` — укороченный формат: „`master`“, „`origin/master`“;

`full` — полный формат: „`refs/heads/master`“, „`refs/remotes/origin/master`“;

`auto` — при выводе на терминал `short`, иначе — `full`;

`no` — не отображать.

**`git rev-parse`** _`reference`_

_вывести полный хэш для указанного объекта_

В качестве объектов могут выступать правки или аннотированные метки. Хэш
аннотированной метки это отдельный хэш, не зависимый от хэша промаркированной
правки.

**`git show`** _`reference`_

_вывести подробную информацию об объекте по ссылке_

В качестве объектов могут выступать правки или аннотированные метки.

#Просмотр изменений
{: id="Просмотр_изменений"}

**`git diff`**

_просмотреть изменения во всех файлах относительно индекса_

**`git diff --staged`**

_просмотреть изменения между выставленными файлами и файлами в репозитории_

**`git diff --text`**

_рассматривать двоичные файлы как текстовые_ (по умолчанию, git игнорирует двоичные файлы и не выводит изменения в них)

**`git diff --stat`**

_вывести сводный отчет по сделанным изменениям_

**`git diff --check`**

_проверить файл на наличие завершающих пробелов_

**`git diff -U`**_`number`_

_установить количество отображаемых строк до и после изменённой строки_

**`git diff`** _`hash`_

_просмотреть изменения во всех файлах относительно указанной правки_

**`git diff`** _`hash`_ _`file`_

_просмотреть изменения в конкретном файле относительно указанной правки_

**`git diff`** _`tag..tag`_

_просмотреть изменения в указанном интервале правок_

**`git diff`** _`base_branch..target_branch`_

_просмотреть изменения между целевой ветвью и общим предком базовой и целевой ветвей_

**`git difftool`**

_просмотреть изменения в специализированной программе_


**`git difftool -y`**

_не выводить подтверждающий запрос при запуске программы просмотра изменений_

**`git blame`** _`file`_

_просмотреть изменения в файле с включением в вывод хэша, автора, даты и прочей информации_

**`git blame -L`** _`starting_line`_**`,`**_`{ ending_line | `_ **`-`**_`offset`_ _`|`_ **`+`**_`offset`_ _`}`_ _`file`_

_отобразить только указанные строки в просматриваемом файле_

Интервал задается указанием номера начальной строки и (опционально) номером
конечной строки или количеством строк до или после начальной.

**`git blame`** _`hash{`_ **`^`**_`[offset] |`_ **`~`**_`[offset] }`_ **`--`** _`file`_

_просмотреть изменения в файле до указанной правки и не включать все последующие_

Правка идентифицируется хэшем или отклонением от правки с указанным хэшем (`^` —
„первый прямой предок указанной“ (если прямых предков несколько), `^n` — „n-й
прямой предок указанной“, `~n` — „указанная, минус n“).

**`git blame`** _`hash`_**`..`**_`hash`_ **`--`** _`file`_

_просмотреть изменения в указанном интервале правок_

#Ветвление
{: id="Ветвление"}

    git branch - показать все текущие ветви и отметить рабочую.
      git branch -v - показать все ветви, отметить текущую и вывести последнюю передачу для каждой ветви.
      git branch -r - показать все ветви в удаленном репозитории.
      git branch <имя_ветви> <имя_родительской_ветви> - создать ветвь.
      git branch <имя_новой_ветви> <имя_метки> - восстановить ветвь с указанной метки.
      git branch -d <имя_ветви> - удалить ветвь. Ветвь должна быть слита.
        git branch -rd <имя_ветви> - удалить удаленную ветвь.
      git branch -D <имя_ветви> - удалить ветвь вне зависимости от того, слита она или нет.
      git branch -m <прежнее_имя> <новое_имя> - переименовать ветвь.

    git checkout <имя_ветви> - выписать указанную ветвь.
      git checkout -b <имя_новой_ветви> <имя_родительской_ветви> - создать новую ветвь и сразу же переключиться на неё.

#Слияние
{: id="Слияние"}

    git merge <имя_ветви> - осуществить прямое слияние текущей ветви с указанной.
      git merge --no-commit <имя_ветви> - выствить слияние.
      git merge --squash <имя_ветви> - выставить объединенные передачи указанной ветви для текущей.
      git cherry-pick <укороченный_дайджест> - осуществить передачу, помеченную дайджестом, для текущей ветви.
      git cherry-pick {-n | --no-commit} <укороченный_дайджест> - выставить передачу, помеченную дайджестом, для текущей ветви.

    git mergetool <программа_сравнения> - использовать программу сравнения для разрешения конфликтов слияния.

    git merge-base <ветвь_1> <ветвь_2> - найти общего предка между двумя ветвями.

#Перебазирование
{: id="Перебазирование"}

    git rebase <базовая_ветвь> <целевая_ветвь> - перебазировать целевую ветвь в конец базовой.
      git rebase <ветвь> - перебазировать текущую ветвь в конец указанной.

    git rebase --onto <базовая_ветвь> <ветвь_посредник> <целевая_ветвь> - перебазировать целевую ветвь в конец базовой, исключая предка в ветви посреднике.
      git reabase --onto <базовая_ветвь> <ветвь_посредник> - перебазировать текущую ветвь в конец базовой, исключая предка в ветви посреднике. 

    git rebase -i <хэш> - войти в интерактивный режим для изменения порядка передач.

#Метки
{: id="Метки"}

    git tag <метка> <имя_ветви> - добавить легковесную метку для указанной ветви.
      git tag <метка> <укороченный_дайджест_передачи> - установить метку для одной из предыдущих передач.
      git tag -a <метка> -m <описание> - добавить аннотированную метку для текущей ветви.
      git tag - возвратить список меток.
      git tag -d <метка> - удалить указанную метку.

#Работа с удаленными репозиториями
{: id="Работа_с_удаленными_репозиториями"}

    git clone <URL> - клонировать репозиторий в локальный каталог.

    git remote add <имя> <URL> - добавить удаленный репозиторий.
    git remote -v - просмотр всех удаленных репозиториев и их URL.
    git remote rm <имя> - удалить указанный удаленный репозиторий.

    git fetch {<url> | <локальное_имя>} - скачать объекты из указанного удаленного репозитория и не сливать их с имеющимися в локальном репозитории.

    git pull {<url> | <локальное_имя>} - скачать объекты из указанного удаленного репозитория и слить их с имеющимися в локальном репозитории.

    git push [<имя_удаленного_репозитория>] - обновить удаленный репозиторий.
      git push --dry-run - имитировать обновление репозитория.
      git push <репозиторий> <ветвь> - обновить удаленный репозиторий, добавив в него только указанную ветвь.
      git push <репозиторий> <ветвь>:<имя_в_удаленном_репозитории> - обновить удаленный репозиторий, добавив в него указанную ветвь, но сохранив её под другим именем.
      git push <удаленный_репозиторий> :<удаляемая_ветвь> - удалить указанную ветвь из удаленного репозитория.
      git push -f - осуществить настойчивое обновление.
      git push --tags - добавить в репозиторий все имеющиеся метки.

      git request-pull <начальная_ссылка> <url_репозитория> [<конечная_ссылка>] - вывысти на экран сводную статистику по передачам, ожидающим вытягивания со стороны менеджера.

#Субмодули
{: id="Субмодули"}

    git submodule - просмотреть субмодули.
      git submodule add <репозиторий> <имя> - создать директорую с указанным именем и добавить в неё указанный репозиторий.
      git submodule init <имя> - инициализировать (добавить запись о субмодуле в .git/config) указанный субмодуль.
      git submodule update <имя> - обновить субмодуль.

#Архивирование
{: id="Архивирование"}

    git archive --format=<tar | zip> --prefix=<имя>/ <ветвь> - поместить все файлы проекта в директорию с указанным именем и создать архив указанного формата.

      git archive --format=tar --prefix=<имя>/ <ветвь> | gzip > <имя>.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата tar и сжать этот архив, сохраняя в файле .tar.gz.

      git archive --prefix=<имя>/ <ветвь> | gzip > `git describe --tags master`.tar.gz - поместить все файлы в директорию с указанным именем, создать архив формата по умолчанию (tar) и сжать этот архив, сохраняя в файле с именем являющимся выводом команды git-describe, добавляя расширение .tar.gz.

        git describe --tags <ветвь> - показать самую последнюю созданную метку, учитывая неаннотированные метки. Вывод команды имеет следующий формат: <имя_тэга>-<количество_сделанных_передач>-g<хэш_последней_передачи>. "g" в выводе означает, что используется VCS git.

#Патчи
{: id="Патчи"}

    git format-patch [<начальная_передача> | <начальная_передача>..<конечная_передача>] - подготовить файлы с патчами для отправки по электронной почте. Использовать либо все передачи начиная с начальной до текущей, либо все передачи в указанном интервале.

      git format-patch -o <директория_вывода> - подготовить файлы патчей и сохранить их в указанной директории.

      git format-patch --stdout - подготовить файлы патчей и вывести их содержимое в консоль.

    git apply <файл_патча> - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданные с помощью следующих команд.

      $ git diff <старт-метка>..<финиш-метка> > <имя>.patch
      $ git log -p <старт-метка>..<финиш-метка> > <имя>.patch

    git am {<mbox-файл> | <файл_патча>} - добавить изменения в файлы проекта из файла патча. Подобным образом можно добавлять файлы, созданный с помощью следующей команды.

      $ git format patch <старт-метка>..<финиш_метка> -о <директория>

      git am -i {<mbox-файл> | <файл-патча>} - добавить изменеия в файлы проекта в интерактивном режиме.

      git am -3 {<mbox-файл> | <файл-патча>} - добавить изменения в файлы проекта. При возникновении конфлика добавить конфликтные маркеры в файлы с конфликтами.

#Отправка патчей по электронной почте
{: id="Отправка_патчей_по_электронной_почте"}

Для отправки почты необходимо установить пакет sendmail.

    git send-email --from=<адрес_отправителя> --to=<адрес_получателя> {<список_файлов> | <директория>} - отправить на указанный адрес либо перечисленные файлы патчей, либо все файлы в указанной директории.

       Настройка git send-email
      --------------------------
        # ~/.gitconfig
        [sendemail]
          smtpserver = <адрес_smtp-сервера> (smtp.gmail.com)
          smtpserverport = <порт_smpt-сервера> ({587 | 465})
          smtpencryption = <криптографический_протокол> ({tls | ssl})
          smtpuser = <логин> (login@gmail.com)
          smtppass = <пароль> (password)
          from = <адрес_отправителя>
          to = <адрес_получателя>
          confirm = {always | never}

    git format-patch --stdout {<начальная_передача> | <интервал>} | git imap-send - загрузить файлы патчей в директорию с черновиками на почтовом сервере.

       Настройка git imap-send
      -------------------------
        # ~/.gitconfig
        [imap]
          folder = <директория_с_черновиками> ([Gmail]/Черновики)
          host = <адрес_почтового_сервера> ({imaps:// | imap://}imap.gmail.com)
          port = <порт_почтового_сервера> ({993 | 143})
          user = <логин> (login@gmail.com)
          pass = <пароль> (password)
          sslverify = <логическое_значение> ({false | true})

#Восстановление и очистка
{: id="Восстановление_и_очистка"}

    git gc - удалить ненужные файлы и произвести оптимизацию локального репозитория.

    git reflog - отобразить журнал изменений.

#Пошаговый поиск проблемных передач
{: id="Пошаговый_поиск_проблемных_передач"}

    git bisect start <проблемная_передача> <беспроблемная_передача> - начать пошаговый поиск в указанном интервале.

      git bisect bad  - отметить передачу как проблемную.
      git bisect good - отметить передачу как беспроблемную.

      git bisect reset - закончить пошаговый поиск.

        git bisect reset <метка> - закончить пошаговый поиск и установить указатель HEAD на отмеченную передачу.

#Gitosis
{: id="Gitosis"}

##Порядок установки менеджера репозиториев Gitosis
{: id="Порядок_установки_менеджера_репозиториев_Gitosis"}

\1. На удаленной машине создать пользователя git.

    # adduser \
    > --system \
    > --group \
    > --disabled-password \
    > --shell /bin/sh \
    > --home /home/git \
    > git

\2. На локальной машине создать публичный ключ для использования вместе с SSH.

    $ ssh-keygen -t rsa

Если не указывать пароль для ключа, то при подключении к SSH-серверу система не будет требовать аутентификации. Обе части ключа (публичная и частная) будут размещены в директории ~/.ssh

\3. Скопировать публичную часть ключа (\<имя_ключа\>.pub) на сервер в директорию /путь/к/публичному/ключу.

\4. Инициализировать Gitosis на удаленной машине.

    # su git -c 'gitosis-init < /путь/к/публичному/ключу'

\4.1 Добавить алиас для IP-адреса удаленной машины в файл /etc/hosts локальной машины.

    $ vim /etc/hosts
    $ cat /etc/hosts
    ...
    192.168.1.14 pavel-server
    ...

##Настройка Gitosis
{: id="Настройка_Gitosis"}

1) Склонировать конфигурацоный репозиторий Gitosis на локальную машину. Если для пользователя был установлен пароль, то он будет запрошен.

    $ git clone git@pavel-server:gitosis-admin.git

или

    $ git clone ssh://git@pavel-server/gitosis-admin.git

2) Перейти в директорию gitosis-admin.git и открыть файл gitosis.conf.

    $ cd gitosis-admin
    $ vim gitosis.conf

3.1) Для настройки доступа к конфигурации Gitosis добавить нового пользователя в графу 'members' секции '\[group gitosis-admin\]'. Для добавления нескольких пользователей, необходимо перечислить их в данной графе, разделяя пробелами. Не стоит добавлять лишние пробелы в конфигурационный файл во избежании возникновения ошибки интерпретатора языка Perl при отправке изменений на сервер*.

    $ cat gitosis.conf
    [group gitosis-admin]
    writable = gitosis-admin
    members = <пользователь_1> <пользователь_2> ...

*Hо не.

    [group gitosis-admin]
      writable = gitosis-admin
      members  = <пользователь_1> <пользователь_2> ...

3.2) Для добавления нового частного репозитория добавить новую секцию.

    [group <группа_чтение-запись>]
    writable = <репозиторий_а>
    members = <пользователь_1> <пользователь_2> ...

Все перечисленные пользователи будут иметь право доступа и записи в созданный репозиторий.

    [group <группа_только_чтение>]
    readonly = <репозиторий_а>
    members = <пользователь_3> <пользователь_4> ...

Здесь, все перечисленные пользователи смогут только клонировать указанный репозиторий. Они не будут иметь право записи.

    [repo <репозиторий_а>]
    daemon = yes

Добавив данную секцию можно открыть публичный доступ к указанному репозиторию. Для того, чтобы пользователи могли скачивать этот репозиторий необходимо запустить git-daemon на удаленной машине.

    # su git -c "git daemon --base-path=<git-home>/repositories"

Таким образом будет открыт общий доступ к данному репозиторию с правом чтения, но не записи. Непривелигированные пользователи будут иметь возможность скачивать репозиторий по протоколу git.

    $ git clone git://<хост>/<путь>.git

Например:

    $ git clone git://pavel-server/project.git

#Примеры
{: id="Примеры"}

##Создание локального репозитория
{: id="Создание_локального_репозитория"}

    1. $ mkdir project; cd project; git init
    2. $ touch README; git add .; git commit -m 'init'
    3. $ mkdir ../project.git; git init --bare ../project.git
    4. $ git remote add origin file://<путь_к_project.git>
    5. $ git push origin master

##Добавление субмодуля
{: id="Добавление субмодуля"}

    1. $ git submodule add <путь> <имя>
    2. $ git submodule init <имя>

##Добавления субмодуля в составе склонированного репозитория
{: id="Добавления_субмодуля_в_составе_склонированного_репозитория"}

    1. $ git submodule init <имя>
    2. $ git submodule update <имя>

##Исправление журнальной записи передачи
{: id="Исправление_журнальной_записи_передачи"}

    1. $ git rebase -i <хэш_родительской_передачи_для_проблемной>
    2. Откроется текстовый редактор с перечнем передач.
    3. Сменить метки pick на edit во всех проблемных передачах.
    4. Сохранить изменения и закрыть редактор.
    5. $ git commit --amend
    6. Откроется редактор с текстом журнальной записи.
    7. Исправить запись, сохранить изменения, закрыть редактор.
    8. $ git rebase --continue
    9. Повторить шаги 5-8 для всех проблемных передач.

##Разбивка одной передачи на несколько
{: id="Разбивка_одной_передачи_на_несколько"}

    1. $ git rebase -i <метка>
    2. Откроется текстовый редактор с перечнем передач.
    3. Сменить метку pick на edit в проблемной передаче.
    4. $ git reset HEAD^
    5. Измененный файл окажется в невыставленной области.
    6. $ git add -e
    7. Отредактировать файл, добавляя необходимые изменения.
    8. $ git commit
    9. Повторить шаги 6-8 для всех изменений.
    10. $ git rebase --continue

<!-- vim: set textwidth=80 colorcolumn=80: -->
