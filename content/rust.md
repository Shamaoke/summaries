---
title: Rust
---

# Содержание #

[Глоссарий](#Глоссарий)

[Управление проектами](#Управление_проектами)

[Модель владения](#Модель_владения)

[Динамическая диспетчеризация](#Динамическая_диспетчеризация)

[Сетевое программирование](#Сетевое_программирование)

[Инструменты командной строки](#Инструменты_командной_строки)

[rustup](#rustup)

[Cargo](#Cargo)

[Справочник](#Справочник)

[Примитивные типы](#Примитивные_типы)

[Комплексные типы](#Комплексные_типы)

[Ссылки](Ссылки)

[Динамическая диспетчеризация](#Ссылки-Динамическая_диспетчеризация)

# Глоссарий #
{: id="Глоссарий" }

`borrow`

: заимствование

`borrow checker`

: контролёр заимствований

`dispatch`

: диспетчеризация

`dynamic dispatch`

: динамическая диспетчеризация

`static dispatch`

: статическая диспетчеризация

# Управление проектами #
{: id="Управление_проектами" }

Существует два типа проектов, создаваемых с помощью системы Rust: **библиотеки**
(libraries) и **исполняемые файлы** (binaries/executables).

Библиотеки предназначены для использования как часть других программ. Библиотеки
позволяют повторно использовать код (свой собственный или созданный другими
разработчиками) во множестве проектов. Библиотеки могут быть опубликованы в
публичном репозитории. Таким образом, обеспечивается возможность обмениваться
кодом между разработчиками.

В системе Rust пакеты с библиотеками именуются **library crate** (или **lib crate**).
Исполнение программы в крейте с библиотекой всегда начинается с файла `src/lib.rs`.

Исполняемый файл — это файл с программой, которую можно запустить и она выполнит
какую-либо задачу. Исполняемые файлы могут быть собранны с включением сторонних
библиотек в свой состав.

В системе Rust пакеты с исполняемыми файлами именуются **binary crate** (или **bin crate**).
Исполнение программы в крейте с исполняемым файлом начинается с функции `main`,
которая должна присутствовать в файле `src/main.rs`.

Непосредственно перед созданием проекта в системе Rust нужно определиться с тем,
какой именно проект мы создаем.

Рабочая среда (_workspace_) — это проект, который содержит другие проекты.
Рабочая среда обеспечивает управление проектами в рамках одного модуля. Кроме
того, посредством рабочих сред можно управлять множеством одноплановых проектов
в рамках одного репозитория.

# Модель владения #
{: id="Модель_владения" }

Модель владения системы Rust основывается на концепции _Resource acquisition is
initialization_ (_RAII_) — овладение ресурсом есть инициализация (овладение
ресурсом через инициализацию).

В соответствии с этой моделью, каждому значению в момент создания назначается
владелец. Как только это значение передается другому владельцу, оно больше не
может быть использовано оригинальным владельцем. Значение будет автоматически
удалено из памяти как только её текущий владелец выйдет из области видимости.

Можно не передавать полное право владения другому владельцу, а предоставлять лишь
временный доступ к значению. Этот механизм называется одалживание (_borrowing_),
а сам объект, одалживающий значение, становиться ссылкой на него (_reference_).
В момент одалживания система Rust проверяет, что время жизни ссылки не больше
времени жизни одолженного значения.

Существует два типа ссылок. Неизменяемые ссылки (_immutable references_ — `&T`),
которые допускают совместное использование значения, но не допускают его
изменения, и изменяемые ссылки (_mutable references_ — `&mut T`), которые допускают
изменение значения, но не допускают его совместного использования. Система Rust
проверяет, что если существует изменяемая ссылка, то одновременно с ней не может
существовать других ссылок (любого типа).

Модель владения системы Rust полностью устнаняет следующие ошибки, связанные с
работой с памятью:

Разыменование нулевого указателя — _null pointer dereference_

: _

Попытка доступа к закрытой области памяти — _restricted area of memory access_

: _

Висячие указатели — _dangling pointers_

: Использование указателей при отсутствии значений, на которые они указывают.

Переполнение буфера — _buffer overflow_

: Попытка доступа к значениям массива за его пределами.

# Динамическая диспетчеризация #
{: id="Динамическая_диспетчеризация" }

Динамические типажи (trait objects — типажи-объекты) служат для реализации
динамической диспетчеризации в системе Rust.

Статические типажи служат для реализации статической диспетчеризации в системе
Rust.

# Сетевое программирование #
{: id="Сетевое_программирование" }

Современные сетевые приложения конструируются как набор независимых компонентов.
Одна часть этих компонентов относится к клиентской части, другая — к серверной и
третья — к инфраструктурной. Все эти компоненты взаимодействуют по сети, а в
основе этого взаимодействия лежит _сетевая модель_.

Сетевая модель определяет субъекты, между которыми происходит взаимодействие,
объекты, на которые направлено это взаимодействие, а также сам механизм этого
взаимодействия.

Сетевая модель описывает как происходит взаимодействие между отправителем
сообщения и его получателем, какой формат должно иметь отправлемое и получаемое
сообщение, как сообщение должно реструктурироваться для того, чтобы его возможно
было передать с использованием имеющийся сетевой инфраструктуры, и как должны
обрабатываться нештатные ситуации например, когда отправленное сообщение
приходит не полностью.

Современной моделью сетевого взаимодействия является модель OSI — Open Systems
Interconnection (basic reference model) — [Сетевая модель взаимодействия открытых
систем][a0da1f].

Хотя модель OSI и определяет семь уровней взаимодействия, для целей понимания
процесса коммуникации посредством всемирной сети достаточно сосредоточиться
только на четырех её уровнях. Это подмножество уровней обычно именуют моделью TCP/IP.

Модель TCP/IP была описана Henrik Frystyk в 1994 году в статье „[The Internet
Protocol Stack][360fc7]“. Модель включает набор стандартов и протоколов для
организации коммуникации во всемирной сети. В основе модели четыре уровня:
сетевого доступа, сетевой, транспортный, и прикладной.

### Прикладной уровень ###
{: id="Прикладной_уровень" }

На прикладном уровне описываются средства передачи данных, имеющих прикладное
значение. Среди таких средств — протокол HTTP.

Коммуникация по протоколу HTTP предполагает наличие как минимум двух субъектов
коммуникации — клиента и сервера. Клиент инициирует соединение с сервером,
формирует запрос и осуществляет его отправку. Сервер принимает запрос, производит
требуемые в запросе действия и возвращает ответ, содержащий результат этих действий.

### Транспортный уровень ###
{: id="Транспортный_уровень" }

На транспортном уровне описываются средства, обеспечивающие надежную передачу
данных. Среди таких средств — протоколы TCP и UDP.

TCP — это протокол передачи данных, требующий предаврительного установления
соединения (_connection-oriented protocol_). При передачи данных по протоколу TCP
сначала устанавливается соединение. Затем передаваемые данные разделяются на
части, называемые сегментами, и начинается их передача. При получении сегментов,
на другом конце соединения осуществляется их пересборка. По завершению передачи
соединение закрывается. Механизм передачи данных по протоколу TCP предполагает
повторную передачу сегмента при его потере и устранение дубликатов сегментов при
их появлении. Таким образом обеспечивается надежная передача данных.

UDP — это протокол передачи данных, не требующий предварительного установления
соединения (_connectionless protocol_). Протокол UDP не гаратнирует целостную
доставку передаваемых данных, но вместо этого обеспечивает высокую скорость передачи.

### Сетевой уровень ###
{: id="Транспортный_уровень" }

На сетевом уровне описываются средства, осуществляющие маршрутизация передаваетмых
данных, то есть, нахождение адресатов и выбор оптимальных маршрутов передачи.
Самое распространенное средство сетевого уровня — протокол IP.

### Канальный уровень ###
{: id="Канальный_уровень" }

На канальном уровне описываются средства осуществления соединения физических
узлов сети.

[a0da1f]: https://ru.wikipedia.org/wiki/Сетевая_модель_OSI

[360fc7]: https://www.w3.org/People/Frystyk/thesis/TcpIp.html

# Инструменты командной строки #
{: id="Инструменты_командной_строки" }

## rustup ##
{: id="rustup" }

`rustup doc --std`

: Открыть документацию стандартной библиотеки в браузере

## Cargo ##
{: id="Cargo" }

`cargo new [--bin] <path>`

: Создать проект с целью, являющейся исполняемым файлом

`cargo new --lib <path>`

: Создать проект с целью, являющейся библиотекой

`cargo check <package>`

: Проверить указанный пакет на наличие ошибок

`cargo build`

: Собрать текущий пакет

`cargo build -p|--package <spec>`

: Собрать указанный пакет текущей рабочей среды

`cargo build --workspace`

: Собрать все пакеты в составе текущей рабочей среды

`cargo test`

: Собрать текущий проект и запустить тесты

`cargo test <testname>`

: Собрать текущий проект и запустить указанный тест

`cargo test -p|--package <spec>`

: Собрать указанный пакет и запустить тесты для него

`cargo test --workspace`

: Собрать все пакеты в составе текущей рабочей среды и запустить тесты для них

`cargo doc`

: Сгенерировать документацию по кодовой базе текущего проекта

`cargo doc --open`

: Сгенерировать документацию по кодовой базе текущего проекта

  Открыть документацию по кодовой базе текущего проекта

# Справочник #
{: id="Справочник" }

## Примитивные типы ##
{: id="Примитивные_типы" }

[`str`](https://doc.rust-lang.org/std/primitive.str.html)

## Комплексные типы ##
{: id="Комплексные_типы" }

[`std::string::String`](https://doc.rust-lang.org/std/string/struct.String.html)

[`std::result::Result`](https://doc.rust-lang.org/std/result/enum.Result.html)

## Модули ##
{: id="Модули" }

[`std::net`](https://doc.rust-lang.org/std/net/)

[`std::net::TcpListener`](https://doc.rust-lang.org/std/net/struct.TcpListener.html)

[`std::net::SocketAddr`](https://doc.rust-lang.org/std/net/enum.SocketAddr.html)

[`std::net::TcpStream`](https://doc.rust-lang.org/std/net/struct.TcpStream.html)

# Ссылки #
{: id="Ссылки" }

## Динамическая диспетчеризация ##
{: id="Ссылки-Динамическая_диспетчеризация" }

 • [Why exactly can't you always do static dispatch in Rust, why is dynamic dispatch sometimes needed? : rust](https://www.reddit.com/r/rust/comments/ta2cei/why_exactly_cant_you_always_do_static_dispatch_in/)

 • [rust - What makes something a "trait object"? - Stack Overflow](https://stackoverflow.com/questions/27567849/what-makes-something-a-trait-object/27570064#27570064)

 • [Dynamic dispatch - Wikipedia](https://en.wikipedia.org/wiki/Dynamic_dispatch)

