---
title: Rust
---

# Содержание #

[Глоссарий](#Глоссарий)

[Управление проектами](#Управление_проектами)

[Модель владения](#Модель_владения)

[Динамическая диспетчеризация](#Динамическая_диспетчеризация)

[Инструментарий](#Инструментарий)

[rustup](#rustup)

[Cargo](#Cargo)

[Справочник](#Справочник)

[Примитивные типы](#Примитивные_типы)

[Комплексные типы](#Комплексные_типы)

[Ссылки](Ссылки)

# Глоссарий #
{: id="Глоссарий" }

`borrow`

: заимствование

`borrow checker`

: контролёр заимствований

`dispatch`

: диспетчеризация

`dynamic dispatch`

: динамическая диспетчеризация

`static dispatch`

: статическая диспетчеризация

# Управление проектами #
{: id="Управление_проектами" }

Существует два типа проектов, создаваемых с помощью системы Rust: **библиотеки**
(libraries) и **исполняемые файлы** (binaries/executables).

Библиотеки предназначены для использования как часть других программ. Библиотеки
позволяют повторно использовать код (свой собственный или созданный другими
разработчиками) во множестве проектов. Библиотеки могут быть опубликованы в
публичном репозитории. Таким образом, обеспечивается возможность обмениваться
кодом между разработчиками.

В системе Rust пакеты с библиотеками именуются **library crate** (или **lib crate**).
Исполнение программы в крейте с библиотекой всегда начинается с файла `src/lib.rs`.

Исполняемый файл — это файл с программой, которую можно запустить и она выполнит
какую-либо задачу. Исполняемые файлы могут быть собранны с включением сторонних
библиотек в свой состав.

В системе Rust пакеты с исполняемыми файлами именуются **binary crate** (или **bin crate**).
Исполнение программы в крейте с исполняемым файлом начинается с функции `main`,
которая должна присутствовать в файле `src/main.rs`.

Непосредственно перед созданием проекта в системе Rust нужно определиться с тем,
какой именно проект мы создаем.

# Модель владения #
{: id="Модель владения" }

Модель владения системы Rust основывается на концепции _Resource acquisition is
initialization_ (_RAII_) — овладение ресурсом есть инициализация (овладение
ресурсом через инициализацию).

В соответствии с этой моделью, каждому значению в момент создания назначается
владелец. Как только это значение передается другому владельцу, оно больше не
может быть использовано оригинальным владельцем. Значение будет автоматически
удалено из памяти как только её текущий владелец выйдет из области видимости.

Можно не передавать полное право владения другому владельцу, а предоставлять лишь
временный доступ к значению. Этот механизм называется одалживание (_borrowing_),
а сам объект, одалживающий значение, становиться ссылкой на него (_reference_).
В момент одалживания система Rust проверяет, что время жизни ссылки не больше
времени жизни одолженного значения.

Существует два типа ссылок. Неизменяемые ссылки (_immutable references_ — `&T`),
которые допускают совместное использование значения, но не допускают его
изменения, и изменяемые ссылки (_mutable references_ — `&mut T`), которые допускают
изменение значения, но не допускают его совместного использования. Система Rust
проверяет, что если существует изменяемая ссылка, то одновременно с ней не может
существовать неизменяемых ссылок (любого типа).

Модель владения системы Rust полностью устнаняет следующие ошибки, связанные с
работой с памятью:

Разыменование нулевого указателя — _null pointer dereference_

: _

Попытка доступа к закрытой области памяти — _restricted area of memory access_

: _

Висячие указатели — _dangling pointers_

: Использование указателей при отсутствии значений, на которые они указывают.

Переполнение буфера — _buffer overflow_

: Попытка доступа к значениям массива за его пределами.

# Динамическая диспетчеризация #
{: id="Динамическая_диспетчеризация" }

Динамические типажи (trait objects — типажи-объекты) служат для реализации
динамической диспетчеризации в системе Rust.

Статические типажи служат для реализации статической диспетчеризации в системе
Rust.

# Инструментарий #
{: id="Инструментарий" }

## rustup ##
{: id="rustup" }

`rustup doc --std`

: Открыть документацию стандартной библиотеки в браузере

## Cargo ##
{: id="Cargo" }

`cargo doc`

: Сгенерировать документацию по кодовой базе текущего проекта

`cargo doc --open`

: Сгенерировать документацию по кодовой базе текущего проекта

  Открыть документацию по кодовой базе текущего проекта

# Справочник #
{: id="Справочник" }

## Примитивные типы ##
{: id="Примитивные_типы" }

[`str`](https://doc.rust-lang.org/std/primitive.str.html)

# Комплексные типы #
{: id="Комплексные_типы" }

[`std::string::String`](https://doc.rust-lang.org/std/string/struct.String.html)

[`std::result::Result`](https://doc.rust-lang.org/std/result/enum.Result.html)

# Ссылки #
{: id="Ссылки" }

 • [Why exactly can't you always do static dispatch in Rust, why is dynamic dispatch sometimes needed? : rust](https://www.reddit.com/r/rust/comments/ta2cei/why_exactly_cant_you_always_do_static_dispatch_in/)

 • [rust - What makes something a "trait object"? - Stack Overflow](https://stackoverflow.com/questions/27567849/what-makes-something-a-trait-object/27570064#27570064)

 • [Dynamic dispatch - Wikipedia](https://en.wikipedia.org/wiki/Dynamic_dispatch)

